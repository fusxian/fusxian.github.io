{"pages":[{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"个人博客开始了","text":"这就算开始正式写博客了，之前陆陆续续在开源中国及头条上写过文章及视频，以后统一在此平台发布，并转发至其他平台。更多信息 ：@程序猿付显","link":"/2020/01/14/first/"},{"title":"Java中的分支结构","text":"Java基础知识系列课程-Java中的分支结构 @程序猿付显 一、if分支结构1:单if分支结构 1234int a =6;if(a&gt;10){ Syste.out.println(\"a 大于 10\");} 2:if-else分支结构 123456int a =6;if(a&gt;10){ Syste.out.println(\"a 大于 10\");}else{ Syste.out.println(\"a 不大于 10\");} 3:多重if-else分支结构 12345678int a =6;if(a&gt;10){ Syste.out.println(\"a 大于 10\");}else if(a == 10){ Syste.out.println(\"a 等于 10\");}else{ Syste.out.println(\"a 小于 10\");} 二、switch分支结构令狐冲参加比武大会 如果获得第一名，将出任武林盟主 如果获得第二名，将出任武当掌门 如果获得第三名，将出任峨嵋掌门 否则，将被逐出师门使用switch代码实现如下:1 int mingCi = 1; switch (mingCi){ case 1: System.out.println(\"出任武林盟主\"); break; case 2: System.out.println(\"出任武当掌门\"); break; case 3: System.out.println(\"出任峨嵋掌门\"); break; default: System.out.println(\"被逐出师门\"); } 三、两个关键字的使用[break continue]break 跳出当前循环或者代码段continue 跳过本次循环,继续下次循环还是上代码看吧 12345678910111213141516171819//使用break --&gt; 1-10中只要遇到有偶数就停止int i = 1;for(;i&lt;11;i++){ if(i%2==0){ break; }}System.out.println(i+\"是偶数!\");//使用continue --&gt; 查找1-10之间所有的偶数和int i = 1;int total = 0;for(;i&lt;11;i++){ if(i%2!=0){ continue; } total+=i;}System.out.println(\"所有的偶数和为:\"+total);","link":"/2020/01/31/java/Java%E4%B8%AD%E7%9A%84%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/"},{"title":"Java中的循环结构","text":"Java基础知识系列课程-Java中的循环结构 @程序猿付显 一、while循环&nbsp;&nbsp;while 循环只最基本也是最简单的一种循环结构:语法: 123while(布尔型表达式){ //循环体 } 此处的布尔表达式可以理解为:一个只要结果为布尔值的任何内容 12345int i = 5;while(i&lt;4){ //循环体 System.out.println(\"这句话不会执行的\");} 二、do…while循环&nbsp;&nbsp;对于 while 语句而言,如果不满足条件,则不能进入循环。但有时候我们需要即使不满足条件,也至少执行一次。do…while 循环和 while 循环相似,不同的是 do…while 循环至少会执行一次语法： 123do{ //循环体}while(布尔表达式); &nbsp;&nbsp;do…while 循环先进行一次循环体的执行,然后才会进行布尔表达式的判断,如果结果为 true 则继续下一次循环,如果为false则直接退出循环 123456789101112int i = 5;//while 循环while(i&lt;4){ //循环体 System.out.println(\"这句话不会执行的\");}//do while循环do{ //循环体 System.out.println(\"不管下边条件真不真,我肯定会执行一次的!\");}while(i&lt;4); 三、for循环&nbsp;&nbsp;for 循环是使用率最高的一种循环,语法相对 while 循环稍微复杂一点 123for(初始化循环参数;循环条件;更新循环变量){ //循环体} 1.初始化循环参数 这是第一步参数: int i = 0; 2.循环条件 初始化参数之后需要判断此条件是否为 true ,如果为 true则执行下一步,如果为 false 则退出循环 3.循环体 这是循环体 执行完执行下一步 4.更新循环变量 待循环体执行完毕,要对循环变量进行更新,一般为自增或者自减:i++ or i–,之后进入第二步进行条件判断 123for(int i = 0;i&lt;10;i++){ System.out.println(\"我要被输出10遍\");} 四、foreach循环&nbsp;&nbsp;这个循环是for循环的一种升级用法,一般针对数组和集合使用,简化普通for循环 1234String[] str = {\"你\",\"好\",\"啊\",\"!\"};for(String s : str){ System.out.println(s);} 其中 s 代表数组 str 中的每一个被循环到的内容,这种写法比之前的for更加的简介,但是没有那容易理解,需要加练习才能加深印象 五、两个关键字的使用[break continue]break 跳出当前循环或者代码段continue 跳过本次循环,继续下次循环还是上代码看吧 12345678910111213141516171819//使用break --&gt; 1-10中只要遇到有偶数就停止int i = 1;for(;i&lt;11;i++){ if(i%2==0){ break; }}System.out.println(i+\"是偶数!\");//使用continue --&gt; 查找1-10之间所有的偶数和int i = 1;int total = 0;for(;i&lt;11;i++){ if(i%2!=0){ continue; } total+=i;}System.out.println(\"所有的偶数和为:\"+total);","link":"/2020/02/01/java/Java%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/"},{"title":"Java中的运算符和表达式","text":"Java基础知识系列课程-Java中的运算符和表达式 @程序猿付显 一、算术运算符&nbsp;&nbsp;算术运算符是我们比较常见的一类运算符，其中包括： + - x / % ++ 自增 – 自减 其中四个运算符是需要我们特别注意的 /&nbsp;&nbsp;除法运算符:此运算符我们需要考虑数据类型的问题eg: 15 / 2 = ? ; 在我们以前的数学运算中它的结果是：2.5&nbsp;&nbsp;而在我们Java中要考虑除数和被除数的数据类型的问题，5、2默认都是整型的，所以结果也必须是整型的，可是结果计算出来是2.5，那程序就在这个结果中取整数部分所以最终的结果为2 %&nbsp;&nbsp;取余也叫取模运算符，我觉得叫取余数更好理解，顾名思义就是两个数做除法，求最终剩下几，那这个剩余没法运算的就是我们要的值eg:15 % 2 = ?; 5对2求余，商2 余1所以最后的结果就是1 ++ 自增运算符，从名字我们就可以看出来–自己玩eg:123i++;//此句话我们对它进行一下翻译i = i + 1; 在原有的基础上做+1的操作，在使用++符号一定注意一个问题 i++ 和 ++i 的区别，i++先使用i完成其他运算再自增，++i先自增再参加其他运算 – 自减运算符，同上eg:123i--;//此句话我们对它进行一下翻译i = i - 1; 在原有的基础上做-1的操作，其他使用同上 其他的几个都是普通的数学运算符，使用上没有太大区别二、赋值运算符 = += -= *= /= %= &nbsp;&nbsp;赋值运算符中最熟悉也是最不熟悉的就是=，大部分人认为这不就是等号吗？其实它在java中我们称之为赋值符号 12345678//1. 赋值符号 =i = i + 1;//2. += 这是一个缩写的形式i+=1;//等同于i = i + 1; //其他类似,此处省略 三、关系运算符 &gt; &lt; &gt;= &lt;= == != &nbsp;&nbsp;判断两个操作之间的关系,结果是一个boolean的结果(只会是ture or false)这里边我们看一个之前不太常见的==,这个才是我们之前一直脑子里的等号 1234567891011int a = 5;int b = 6;if(a &gt; b){ System.out.println(\"a 比 b大\");}if(a == b){ System.out.println(\"a 和 b一样大\");}if(a != b){ System.out.println(\"a 和 b不一样大\");} 四、逻辑运算符&nbsp;&nbsp;对两个布尔类型的操作数进行操作,其结果也是boolean ! 取反 &amp;&amp; 短路与 || 短路或 &amp; 逻辑与 | 逻辑或 运算符 用法 含义 说明 实例 结果 &amp;&amp; a&amp;&amp;b 短路与 ab 全为 true 时，计算结果为 true，否则为 false。 2&gt;1&amp;&amp;3&lt;4 true || ab 短路或 ab 全为 false 时，计算结果为 false，否则为 true。 2&lt;1||3&gt;4 false ! !a 逻辑非 a 为 true 时，值为 false，a 为 false 时，值为 true !(2&gt;4) true | ab 逻辑或 ab 全为 false 时，计算结果为 false，否则为 true 1&gt;2|3&gt;5 false &amp; a&amp;b 逻辑与 ab 全为 false 时，计算结果为 false，否则为 true 1&lt;2&amp;3&lt;5 true &amp;&amp; 与 &amp; 区别：如果 a 为 false，则不计算 b（因为不论 b 为何值，结果都为 false） || 与 | 区别：如果 a 为 true，则不计算 b（因为不论 b 为何值，结果都为 true） 五、条件运算符&nbsp;&nbsp;条件运算符也称之为三目运算符,也是以后我们会常用的一种运算符 Test？语句块1：语句块2； Test是boolean结果的表达式 结果为true时执行语句块1 结果为false时执行语句块2 1234567//需求：比较a b两个数的大小,将大的数存入c中int a = 5;int b = 6;int c = 0;c = a&gt;b?a:b;//此时c中存储的就是最大的值也就是6System.out.println(c);","link":"/2020/01/31/java/Java%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"Java简介","text":"Java基础知识系列课程 @程序猿付显 一、第一个程序演示在我们正式学习JAVA之前,我们先通过这样一个例子来感受一下程序的魅力 代码： 123456789101112public class Demo01 { public static void main(String[] args) throws Exception{ String descrption =\"Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。\" + \"\\r\\nJava可运行于多个平台，如Windows, Mac OS，及其他多种UNIX版本的系统。\" + \"\\r\\n本教程通过简单的实例将让大家更好的了解JAVA编程语言\"; for(int i=0;i&lt;descrption.length();i++){ System.out.print(descrption.charAt(i)); Thread.sleep(80); } }} 如何让这段代码运行呢?那我们来看一下这段代码的运行过程 过程： 使用记事本在D盘中新建一个文件,命名为”Demo01.java” 将此段代码复制到此文件中,并且保存文件 使用快捷键 “win + R” 打开运行窗口,在运行窗口中输入 “cmd” 点击 “确定” 按钮 在弹出的黑色框内输入 “D:” 按下键盘中的 “Enter” 键 紧接着输入 “javac Demo01.java” 之后再次输入 “java Demo01” 现在我们就可以看到这段儿程序的展示效果了 TODO：插入gif图片 二、Java简介看了以上的效果展示,那我们再了解一些关于Java的基础知识 什么是Java?Java 是由 Sun Microsystems 在 1995 年首先发布的编程语言和计算平台。有许多应用程序和 Web 站点只有在安装 Java 后才能正常工作，而且这样的应用程序和 Web 站点日益增多。Java 快速、安全、可靠。从笔记本电脑到数据中心，从游戏控制台到科学超级计算机，从手机到互联网，Java 无处不在！——来自于 java官方解释 那么对于我们开发者来说Java代表着什么? 1：一种面向对象的开发语言Sun 公司对 Java 编程语言的解释是：Java 编程语言是个简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言。 2：可以跨平台运行程序的环境Java 平台是基于 Java 语言的平台，可以运行在任何的操作系统上，这样的平台非常流行。微软公司也推出了与之竞争的.NET平台以及模仿Java的C#语言，但此平台只支持windows系统 三、Java发展历程Java语言并不是一开始就叫 Java 也没有一下这么火，也经历了一个发展过程: 20世纪90年代，硬件领域出现了单片式计算机系统，这种价格低廉的系统一出现就立即引起了自动控制领域人员的注意，因为使用它可以大幅度提升消费类电子产品（如电视机顶盒、面包烤箱、移动电话等）的智能化程度。 Sun公司为了抢占市场先机，在1991年成立了一个称为Green的项目小组，帕特里克、詹姆斯·高斯林、麦克·舍林丹和其他几个工程师一起组成的工作小组在加利福尼亚州门洛帕克市沙丘路的一个小工作室里面研究开发新技术，专攻计算机在家电产品上的嵌入式应用。由于C++所具有的优势，该项目组的研究人员首先考虑采用C++来编写程序。但对于硬件资源极其匮乏的单片式系统来说，C++程序过于复杂和庞大。另外由于消费电子产品所采用的嵌入式处理器芯片的种类繁杂，如何让编写的程序跨平台运行也是个难题。为了解决困难，他们首先着眼于语言的开发，假设了一种结构简单、符合嵌入式应用需要的硬件平台体系结构并为其制定了相应的规范，其中就定义了这种硬件平台的二进制机器码指令系统（即后来成为“字节码”的指令系统），以待语言开发成功后，能有半导体芯片生产商开发和生产这种硬件平台。对于新语言的设计，Sun公司研发人员并没有开发一种全新的语言，而是根据嵌入式软件的要求，对C++进行了改造，去除了留在C++的一些不太实用及影响安全的成分，并结合嵌入式系统的实时性要求，开发了一种称为 Oak 的面向对象语言。 由于在开发Oak语言时，尚且不存在运行字节码的硬件平台，所以为了在开发时可以对这种语言进行实验研究，他们就在已有的硬件和软件平台基础上，按照自己所指定的规范，用软件建设了一个运行平台，整个系统除了比C++更加简单之外，没有什么大的区别。1992年的夏天，当Oak语言开发成功后，研究者们向硬件生产商进行演示了Green操作系统、Oak的程序设计语言、类库和其硬件，以说服他们使用Oak语言生产硬件芯片，但是，硬件生产商并未对此产生极大的热情。因为他们认为，在所有人对Oak语言还一无所知的情况下，就生产硬件产品的风险实在太大了，所以Oak语言也就因为缺乏硬件的支持而无法进入市场，从而被搁置了下来。1994年6、7月间，在经历了一场历时三天的讨论之后，团队决定再一次改变了努力的目标，这次他们决定将该技术应用于万维网。他们认为随着Mosaic浏览器的到来，因特网正在向同样的高度互动的远景演变，而这一远景正是他们在有线电视网中看到的。作为原型，帕特里克·诺顿写了一个小型万维网浏览器WebRunner。1995年，互联网的蓬勃发展给了Oak机会。业界为了使死板、单调的静态网页能够“灵活”起来，急需一种软件技术来开发一种程序，这种程序可以通过网络传播并且能够跨平台运行。于是，世界各大IT企业为此纷纷投入了大量的人力、物力和财力。这个时候，Sun公司想起了那个被搁置起来很久的Oak，并且重新审视了那个用软件编写的试验平台，由于它是按照嵌入式系统硬件平台体系结构进行编写的，所以非常小，特别适用于网络上的传输系统，而Oak也是一种精简的语言，程序非常小，适合在网络上传输。Sun公司首先推出了可以嵌入网页并且可以随同网页在网络上传输的Applet（Applet是一种将小程序嵌入到网页中进行执行的技术），并将Oak更名为Java（在申请注册商标时，发现Oak已经被人使用了，再想了一系列名字之后，最终，使用了提议者在喝一杯Java咖啡时无意提到的Java词语）。5月23日，Sun公司在Sun world会议上正式发布Java和HotJava浏览器。IBM、Apple、DEC、Adobe、HP、Oracle、Netscape和微软等各大公司都纷纷停止了自己的相关开发项目，竞相购买了Java使用许可证，并为自己的产品开发了相应的Java平台。 1995年5月23日，Java语言诞生1996年1月，第一个JDK-JDK1.0诞生1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术1996年9月，约8.3万个网页应用了JAVA技术来制作1997年2月18日，JDK1.1发布1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录1997年9月，JavaDeveloperConnection社区成员超过十万1998年2月，JDK1.1被下载超过2,000,000次1998年12月8日，JAVA2企业平台J2EE发布1999年6月，SUN公司发布Java的三个版本：标准版（JavaSE,以前是J2SE）、企业版（JavaEE以前是J2EE）和微型版（JavaME，以前是J2ME）2000年5月8日，JDK1.3发布2000年5月29日，JDK1.4发布2001年6月5日，NOKIA宣布，到2003年将出售1亿部支持Java的手机2001年9月24日，J2EE1.3发布2002年2月26日，J2SE1.4发布，自此Java的计算能力有了大幅提升2004年9月30日18:00PM，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.02005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名，以取消其中的数字”2”：J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME2006年12月，SUN公司发布JRE6.02009年04月20日，甲骨文74亿美元收购Sun。取得java的版权。2010年11月，由于甲骨文对于Java社区的不友善，因此Apache扬言将退出JCP[4]。2011年7月28日，甲骨文发布java7.0的正式版。2014年3月18日，Oracle公司发表Java SE 8。‘ 四、为什么要学Java？因为学校规定必须学，不学就没有学分，没有学分就没有毕业证！其实我们干好多事都是这样的原因，回想一下你为什么要学生物 化学 地理 政治？？当然了这不是根本原因，根本原因还在于这些内容是可以帮我们完成平常工作、生活中 遇到的问题。那么我们为什么要学习Java呢？大体有以下几种：1：自己的兴趣爱好，就喜欢编程，就喜欢Java2：被逼的不学不行，不学不给毕业证3：学习Java可以找到一份很不错的工作，来满足自己日益不断变大的物质、精神需求 五、怎么才能学好Java？不管你是什么原因来学习Java，既然已经到了这个地步了，那我们就来说一说怎么才能学好Java。最简单的办法通常也是最笨的办法： 多看 多写 多练 多思考 多总结 …等总之一个字 多 就对了！！！ 那总得有个步骤吧？ 第一阶段：熟悉各种概念，这个阶段也是最容易放弃的阶段，因为一上来全都是各种从来没见过的陌生名词及专业解释，怎么办？这时候需要拿出来我们小学认汉字、认数字的状态，“ 1 ”这个就是一，“ 兔 ”这个就是小兔子的兔，每天重复之前的内容，当你看到它的时候你能张口说出他就是 小兔子的兔，那么ok 这个概念你就学会了; 第二阶段:多练基础代码,需要把课堂的例子,书本上的例子,你能找到的所有的例子,多动手敲一敲,记住一些编程的套路; 第三阶段多思考:动手敲完以上代码,需要思考一下程序的思路,按照自己的思路再次进行编码,然后对照第二阶段敲的代码,看看哪些地方有问题,是什么样的问题,记录一下,避免下一次再次出现; 第四阶段多总结:需要把你平时敲代码遇到的问题以及解决方案进行总结,总结是对你之前学习内容的肯定也是对以后学习的好的开端; 第五阶段这个阶段最简单了 - - - - 遇到新的概念、知识点重复前四个阶段就ok了. 六、学好Java有啥用？做好社会主义接班人?是的,学习好Java确实可以做好社会主义接班人,但是国外的人学Java有啥用?目前我们使用的电子设备中比如 手机 电视 手表 等智能设备中一大部分都是Android的操作系统,那在这样的系统中开发应用是使用的主要语言就是Java;除了我们能看到的设备,我们平时过得两个购物节 淘宝的双十一 双十二,这样的大规模的网站它的主要系统也是使用Java来进行编写的.那跟我们又有什么关系呢?学好Java可以使我们找到一份薪水不错的工作!就这么简单! 七、开始Java语言的详细内容1：Java在开发上的分类JavaSE Java 平台标准版这一部分是Java语言的核心内容，其中包括数据库连接、接口、数据结构、输入输入、网络编程、文件读取、多线程等等内容； JavaEE Java平台企业版这一部分是在JavaSE的基础上做的扩展，以适应企业级的开发，增加了 EJB、Servlet、JSP、XML、事物控制等，这一部分才是我们学习Java以及以后工作中应用的重点内容； JavaME Java平台微型版这一部分在以前的智能机（塞班）系统，诺基亚手机中应用最广。 JavaEE和JavaME都是在JavaSE的基础上做的扩展，也就是说JavaSE是我们学习Java的核心课程，之后我们会进行JavaEE企业级开发的学习。 2：Java的特性Java语言是简单的：Java语言的语法与C语言和C++语言很接近，使得大多数程序员很容易学习和使用。另一方面，Java丢弃了C++中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。特别地，Java语言不使用指针，而是引用。并提供了自动的废料收集，使得程序员不必为内存管理而担忧。 Java语言是面向对象的：Java语言提供类、接口和继承等面向对象的特性，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为implements）。Java语言全面支持动态绑定，而C++语言只对虚函数使用动态绑定。总之，Java语言是一个纯的面向对象程序设计语言。 Java语言是分布式的：Java语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、ServerSocket等。Java的RMI（远程方法激活）机制也是开发分布式应用的重要手段。 Java语言是健壮的：Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择。Java的安全检查机制使得Java更具健壮性。 Java语言是安全的：Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。除了Java语言具有的许多安全特性以外，Java对通过网络下载的类具有一个安全防范机制（类ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类SecurityManager）让Java应用设置安全哨兵。 Java语言是体系结构中立的：Java程序（后缀为java的文件）在Java平台上被编译为体系结构中立的字节码格式（后缀为class的文件），然后可以在实现这个Java平台的任何系统中运行。这种途径适合于异构的网络环境和软件的分发。 Java语言是可移植的：这种可移植性来源于体系结构中立性，另外，Java还严格规定了各个基本数据类型的长度。Java系统本身也具有很强的可移植性，Java编译器是用Java实现的，Java的运行环境是用ANSI C实现的。 Java语言是解释型的：如前所述，Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java平台的任何系统中运行。在运行时，Java平台中的Java解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。 Java是高性能的：与那些解释型的高级脚本语言相比，Java的确是高性能的。事实上，Java的运行速度随着JIT(Just-In-Time）编译器技术的发展越来越接近于C++。 Java语言是多线程的：在Java语言中，线程是一种特殊的对象，它必须由Thread类或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为Thread(Runnable)的构造子将一个实现了Runnable接口的对象包装成一个线程，其二，从Thread类派生出子类并重写run方法，使用该子类创建的对象即为线程。值得注意的是Thread类已经实现了Runnable接口，因此，任何一个线程均有它的run方法，而run方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。Java语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为synchronized）。 Java语言是动态的：Java语言的设计目标之一是适应于动态变化的环境。Java程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。这也有利于软件的升级。另外，Java中的类有一个运行时刻的表示，能进行运行时刻的类型检查。 3：Java语言的运行机制Java语言是一种解释型的语言，Java代码在计算机中的运行过程是这样的：所有的Java代码都被保存在一个xxx.java的文件中，经过编译器的编译生成一个xxx.class的字节码文件，之后这个字节码文件通过Java虚拟机解释成计算机能识别的机器代码，完成相应的功能操作。 那么这里边有一个关键点：Java虚拟机 它的主要工作就是负责将字节码文件解释成机器能够识别的机器代码，它是由软件和硬件模拟出来的可以干活的机器所以就叫Java 虚拟机（Java Virtual Machine JVM） Java虚拟机的功能类似一个翻译，将机器不能识别的字节码文件解释成机器代码","link":"/2020/01/14/java/Java%E7%AE%80%E4%BB%8B/"},{"title":"Java变量和数据类型","text":"Java基础知识系列课程-Java变量和数据类型 @程序猿付显 一、Java中的变量、常量、注释1：变量变量是什么呢？–不断变化的量，这个概念需要有深刻地体会，只要在程序中遇到有不确定的值或者需要不断改变的值那么这个地方一定需要用到变量。那我们先来看看变量的声明和定义的过程：&nbsp;&nbsp;声明一个变量 12//根据类型开辟空间int a; &nbsp;&nbsp;赋值 12//将数据存入空间a = 10; &nbsp;&nbsp;使用变量 12//取出数据使用变量System.out.println(a); 2：常量常量又是什么呢？–恒定不变的量，那怎么表示呢？&nbsp;&nbsp;字面常量&nbsp;&nbsp;&nbsp;&nbsp;字面常量也被称之为常量值，比如：5 15 -1 false 3.5 ‘w’ “hello”等 &nbsp;&nbsp;定义常量&nbsp;&nbsp;&nbsp;&nbsp;常量不同于常量值，它可以在程序中用符号来代替常量值使用，因此在使用前必须先定义。Java 语言使用 final 关键字来定义一个常量，其语法如下所示：&nbsp;&nbsp;&nbsp;&nbsp;final dataType variableName = value 12345678910public class HelloWorld { // 静态常量 public static final double PI = 3.14; // 声明成员常量 final int y = 10; public static void main(String[] args) { // 声明局部常量 final double x = 3.3; }} 3：注释&nbsp;&nbsp;单行注释&nbsp;&nbsp;&nbsp;&nbsp;单行注释：快捷键Ctrl+/&nbsp;&nbsp;再次按撤销注释&nbsp;&nbsp;&nbsp;&nbsp;一般用来注释局部变量。 123//这是单行注释int a = 5;a = a + 6; &nbsp;&nbsp;多行注释&nbsp;&nbsp;&nbsp;&nbsp;多行注释：Ctrl+Shift+/&nbsp;&nbsp;撤销Ctrl+Shift+\\&nbsp;&nbsp;&nbsp;&nbsp;可用来注释文件头、算法实现、方法中的复杂代码块、修改记录 12345678/*这个是多行注释，此区域全部都不会被编译int a = 5;a = a + 6;*/int j = 0;j++;System.out.println(j); &nbsp;&nbsp;文档注释&nbsp;&nbsp;&nbsp;&nbsp;文档注释：Shift+Alt+J&nbsp;&nbsp;&nbsp;&nbsp;可用来注释类、接口、静态方法、成员方法、静态变量、成员变量、常量&nbsp;&nbsp;&nbsp;&nbsp;或者在定义完：注释类、接口、静态方法、成员方法、静态变量、成员变量、常量后，在上面加上/**在按Enter建也能生成 12345678/** * 这个是文档注释，此处描述此类的作用及其他信息 */public class Hello{ public static void main(String[] args){ System.out.println(\"HelloWord!\"); }} 4：命名规则&nbsp;&nbsp;命名规则参照《阿里Java技术手册》，现已改名为《Java技术手册》阿里Java技术手册 二、输入、输出语句1：输入语句&nbsp;&nbsp;java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入&nbsp;&nbsp;Scanner类的基本语法： 12Scanner scan = new Scanner(System.in);String line = scan.nextLine(); 2：输出语句&nbsp;&nbsp;输出语句是我们刚学习Java程序时写的第一段儿代码 1System.out.println(\"Hello World\"); 三、数据类型1：基本数据类型&nbsp;&nbsp;java中有8种基本数据类型，这8种基本数据类型就要像记自己名字一样记下来 类型 长度 范围 例子 byte 8位 -128~127 (-27 ~ 27-1) byte b = 10; short 16位 -32768~32767(-215 ~ 215-1) short s = 1000; int 32位 -2,147,483,648~2,147,483,647(-231 ~ 231-1) int i = 20201228; long 64位 -9,223,372,036,854,775,808~9,223,372,036,854,775,807(-263 ~ 263-1) long l = 5L; char 16位 \\u0000~\\uFFFF char c = ‘A’; float 32位 3.4E-038~3.4E+038 float f = 3.14F; double 64位 1.7E-308~1.7E+308 double d = 3.1415026; boolean 1位 false、true boolean flag = true; 2：引用数据类型&nbsp;&nbsp;引用数据类型区别于基本数据类型主要在使用过程中，引用数据类型主要有三种 数组 接口 类 &nbsp;&nbsp;其中有我们目前为止常用的几个： 123Scanner scan = new Scanner(System.in);String str = \"abc\";char data[] = {'a','b','c','d'}; 那基本数据类型和引用数据类型之间到底有什么区别呢？这就需要我们对Java中的堆和栈有一个初步的了解 3：内存中的堆和栈&nbsp;&nbsp;基本数据类型在被创建时，在栈上给其划分一块内存，将数值直接存储在栈上&nbsp;&nbsp;引用数据类型在被创建时，首先要在栈上给其引用（句柄）分配一块内存，而对象的具体信息都存储在堆内存上，然后由栈上面的引用指向堆中对象的地址对于这样的文字描述我们还是不能够真切的体会，那我们就用一张图简单演示一下从这张简图中我们可以看到，基本数据类型在栈中存储两部分内容，一部分为变量名称，第二部分为此变量所对应的值引用数据类型在栈中也存储两部分内容，一部分为变量名称，第二部分为此变量在堆中的地址，此时在堆中存储的才是此变量所对应的值 4：进制之间的转换&nbsp;&nbsp;进制有二进制、八进制、十进制、十六进制,此处我引入简书上的一篇文章，让大家更清晰的看明白进制间的转换 二进制、八进制、十进制、十六进制之间转换 –MPPC https://www.jianshu.com/p/555cd32e99cc 四、关键字在编译工具中会有红色提示的都属于关键字，也称之为保留字如下：","link":"/2020/01/15/java/Java%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"Java中的数组","text":"Java基础知识系列课程-Java中的数组 @程序猿付显 &nbsp;&nbsp;数组也是一种变量,它可以存储一组固定长度、相同数据类型的数据 一、一维数组 声明 int[] array; –&gt;声明类型为int的数组 int array[]; –&gt;这种方式也是允许的 初始化 array = new int[5]; –&gt;初始化长度为5的数组 array = new int[]{0,1,2,3,4}; –&gt;直接填入5个数据完成初始化和赋值操作 array = {0,1,2,3,4}; –&gt;静态初始化,直接填入5个数据完成初始化和赋值操作 赋值 array[0] = 0; –&gt;使用下标从 [0] 开始进行赋值 使用 int i = array[0]; –&gt;此处也是使用下标从第一个[0]开始进行遍历的 数据在堆内存中的存储模型 123456789101112131415//1.声明数组int[] numbers = null;//2.初始化数组numbers = new int[5];//3.从下标0开始挨个赋值for(int i = 0;i&gt;numbers.length;i++){ numbers[i] = i;}//4.使用foreach遍历输出数组中的每一个元素for(int number:numbers){ System.out.println(number);} 二、二维数组&nbsp;&nbsp;二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组&nbsp;&nbsp;语法格式为: int[] [] arr = new int[length1][length2]; length1 为行数 length2 为列数 1234//静态初始化 int arr[][] = { {1,2,3}, {4,5,6}, {7,8,9} }; //动态初始化int n = 1; int[][] arr = new int[3][3]; for ( int i = 0; i &lt; arr.length; i++ ){ for ( int j = 0; j &lt; arr[i].length; j++ ){ arr[i][j] = n; n++; } } 以上代码执行完毕后再堆内存中的模型如图: 三、数组的使用&nbsp;&nbsp;以上数组演示的都是int类型的,我们还可以用其他任意的类型,包括但不限于八种基本数据类型、String、类等。 数组是内存中有序数据的集合，数组中的每个元素具有相同的数据类型。 数组必须先声明，对其初始化以后才能使用。对数组初始化有静态初始化和动态初始化两种方式。 通过下标来访问数组中的每个元素。 数组可以分为一维数组和多维数组。二维数组可以理解为一维数组的集合。","link":"/2020/02/02/java/Java%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/"},{"title":"SqlServer2012的安装过程","text":"SQL基础系列课程-SqlServer2012的安装过程 @程序猿付显 同学们请注意,视频已经录制完毕,待上传到网易云课堂,组织统一时间观看并完成相关作业 下载软件在百度搜索或者其他地方很方便可以找到SqlServer2012的下载地址 百度网盘 提取码：99kq(此部分已是下载好的三个文件) 官网-SqlServer2012下载地址 点击下载会有提示,我们选择 X64 的三个即可 安装软件下载完之后,点击其中的exe文件解压缩会得到一个名字为”SQLFULL_x64_CHS”的文件夹,双击其中的”SETUP.EXE”,一路 NEXT即可… 安装SQL功能在功能选择中点击 “全选”再次一路NEXT即可… 在数据库引擎配置中选择混合模式并输入密码(我输入的是1,你可以随意,只要你记得就行),并且添加当前用户 在Analysis Service配置中添加当前用户 在分布式重播控制器中添加当前用户 随后关闭即可… 设置网络启动方式及网络配置设置网络启动方式在控制面板中 –&gt; 管理工具 –&gt; 服务 –&gt;SQL Server (MSSQLSERVER) –&gt; 右键属性–&gt;启动类型可选择自动、自动(延迟启动)、手动、禁止四种 网络配置SqlServer配置器 –&gt; SQL Server 网络配置 –&gt; MSSQLSERVER 的协议 –&gt; TCP/IP –&gt;启用,之后重启 SQL Server (MSSQLSERVER)服务即可","link":"/2020/02/04/SqlServer/SqlServer%E7%9A%84%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"title":"SqlServer的基础知识","text":"SQL基础系列课程-SqlServer的基础知识 @程序猿付显 同学们请注意,视频已经录制完毕,待上传到网易云课堂,组织统一时间观看并完成相关作业 数据库系统的简介&nbsp;&nbsp;我们的课程将向大家讲解如何使用一个管理软件以一种容易理解的、便于操作的方式来存储和获取数据,整套课程内容包括以下几项: 数据库的基本概念 使用SqlServer 2012管理工具管理数据库 创建数据库、表、约束 使用T-SQL 对数据进行增加、删除、修改和查询的操作 学会以上内容可以为我们在Java和.NET程序中进行数据库开发提供基础 数据库的相关基本概念数据&nbsp;&nbsp;人们对数据的定义多种多样，在各个行业或领域对数据的定义都有自己的看法，从我们的现实生活中来看，数据是对现实生活的理性描述，尽可能地从数量上反映现实世界&nbsp;&nbsp;例如:你可以现在掏出你的手机,打开微信运动看看今天走了几步,这个就是使用数据来对你今天的步行情况的一个描述,等等这样的例子非常多. 数据库&nbsp;&nbsp;库的概念大家应该会有很多现实的例子,比如车库:用来存放汽车的;我们的丹江口水库:用来存储水的;那么我们的数据库:就是用来存储数据的. 数据库管理系统&nbsp;&nbsp;管理数据库及数据的计算机软件,也就是我们将要学习的SqlServer2012管理工具 数据库和应用程序&nbsp;&nbsp;此图片描述了数据库和应用程序之间的一个关系,同时也拓展大家对于本课程的应用,让大家提前了解我们数据库到底跟应用程序之间是一个什么样的联系! 了解数据库技术的发展史 文件系统 使用磁盘文件夹存储数据 第一代数据库 出现了网状模型、层次模型的数据库 第二代数据库 关系型数据库和结构化查询语句 当前 关系数据库为主流,非关系型数据库大量使用 常见的关系型数据库Mysql数据库&nbsp;&nbsp;MySQL是最受欢迎的开源SQL数据库管理系统，它由 MySQL AB开发、发布和支持。MySQL AB是一家基于MySQL开发人员的商业公司，它是一家使用了一种成功的商业模式来结合开源价值和方法论的第二代开源公司。MySQL是MySQL AB的注册商标。&nbsp;&nbsp;MySQL是一个快速的、多线程、多用户和健壮的SQL数据库服务器。MySQL服务器支持关键任务、重负载生产系统的使用，也可以将它嵌入到一个大配置(mass- deployed)的软件中去。 Microsoft SQL Server数据库&nbsp;&nbsp;SQL Server是由微软开发的数据库管理系统，是Web上最流行的用于存储数据的数据库，它已广泛用于电子商务、银行、保险、电力等与数据库有关的行业。&nbsp;&nbsp;目前最新版本是SQL Server 2005，它只能在Windows上运行，操作系统的系统稳定性对数据库十分重要。并行实施和共存模型并不成熟，很难处理日益增多的用户数和数据卷，伸缩性有限。&nbsp;&nbsp;SQL Server 提供了众多的Web和电子商务功能，如对XML和Internet标准的丰富支持，通过Web对数据进行轻松安全的访问，具有强大的、灵活的、基于Web的和安全的应用程序管理等。而且，由于其易操作性及其友好的操作界面，深受广大用户的喜爱。 Oracle数据库&nbsp;&nbsp;Oracle Database，又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统。它是在数据库领域一直处于领先地位的产品。可以说Oracle数据库系统是目前世界上流行的关系数据库管理系统，系统可移植性好、使用方便、功能强，适用于各类大、中、小、微机环境。它是一种高效率、可靠性好的 适应高吞吐量的数据库解决方案。 Postgresql数据库&nbsp;&nbsp;PostgreSQL是以加州大学伯克利分校计算机系开发的 POSTGRES，现在已经更名为PostgreSQL，版本 4.2为基础的对象关系型数据库管理系统（ORDBMS）。PostgreSQL支持大部分 SQL标准并且提供了许多其他现代特性：复杂查询、外键、触发器、视图、事务完整性、MVCC。同样，PostgreSQL 可以用许多方法扩展，比如，通过增加新的数据类型、函数、操作符、聚集函数、索引。免费使用、修改、和分发 PostgreSQL，不管是私用、商用、还是学术研究使用。&nbsp;&nbsp;PostgreSQL 是一个免费的对象-关系数据库服务器(数据库管理系统)，它在灵活的 BSD-风格许可证下发行。它提供了相对其他开放源代码数据库系统(比如 MySQL 和 Firebird)，和专有系统(比如 Oracle、Sybase、IBM 的 DB2 和 Microsoft SQL Server)之外的另一种选择。 Sybase数据库&nbsp;&nbsp;美国Sybase公司研制的一种关系型数据库系统，是一种典型的UNIX或WindowsNT平台上客户机/服务器环境下的大型数据库系统。&nbsp;&nbsp;Sybase提供了一套应用程序编程接口和库，可以与非Sybase数据源及服务器集成，允许在多个数据库之间复制数据，适于创建多层应用。系统具有完备的触发器、存储过程、规则以及完整性定义，支持优化查询，具有较好的数据安全性。&nbsp;&nbsp;Sybase通常与SybaseSQLAnywhere用于客户机/服务器环境，前者作为服务器数据库，后者为客户机数据库，采用该公司研制的PowerBuilder为开发工具，在我国大中型系统中具有广泛的应用。 DB2数据库&nbsp;&nbsp;DB2主要应用于大型应用系统，具有较好的可伸缩性，可支持从大型机到单用户环境，应用于所有常见的服务器操作系统平台下。&nbsp;&nbsp;DB2提供了高层次的数据利用性、完整性、安全性、可恢复性，以及小规模到大规模应用程序的执行能力，具有与平台无关的基本功能和SQL命令。DB2采用了数据分级技术，能够使大型机数据很方便地下载到LAN数据库服务器，使得客户机/服务器用户和基于LAN的应用程序可以访问大型机数据，并使数据库本地化及远程连接透明化。&nbsp;&nbsp;DB2以拥有一个非常完备的查询优化器而著称，其外部连接改善了查询性能，并支持多任务并行查询。 DB2具有很好的网络支持能力，每个子系统可以连接十几万个分布式用户，可同时激活上千个活动线程，对大型分布式应用系统尤为适用。 Access数据库&nbsp;&nbsp;Microsoft Office Access是由微软发布的关系数据库管理系统。它结合了 MicrosoftJet Database Engine 和 图形用户界面两项特点，是 Microsoft Office 的系统程序之一。&nbsp;&nbsp;Microsoft Office Access是微软把数据库引擎的图形用户界面和软件开发工具结合在一起的一个数据库管理系统。它是微软OFFICE的一个成员, 在包括专业版和更高版本的office版本里面被单独出售。&nbsp;&nbsp;MS ACCESS以它自己的格式将数据存储在基于Access Jet的数据库引擎里。它还可以直接导入或者链接数据(这些数据存储在其他应用程序和数据库)。&nbsp;&nbsp;软件开发人员和数据架构师可以使用Microsoft Access开发应用软件,“高级用户”可以使用它来构建软件应用程序。和其他办公应用程序一样，ACCESS支持Visual Basic宏语言,它是一个面向对象的编程语言,可以引用各种对象，包括DAO(数据访问对象),ActiveX数据对象,以及许多其他的ActiveX组件。可视对象用于显示表和报表，他们的方法和属性是在VBA编程环境下，VBA代码模块可以声明和调用Windows操作系统函数。 常见的非关系型数据库Mongodb数据库&nbsp;&nbsp;MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。&nbsp;&nbsp;MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。 Redis数据库&nbsp;&nbsp;Redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。&nbsp;&nbsp;Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。 Hbase数据库&nbsp;&nbsp;HBase是一个分布式的、面向列的开源数据库，该技术来源于 Fay Chang 所撰写的Google论文“Bigtable：一个结构化数据的分布式存储系统”。就像Bigtable利用了Google文件系统（File System）所提供的分布式数据存储一样，HBase在Hadoop之上提供了类似于Bigtable的能力。&nbsp;&nbsp;HBase是Apache的Hadoop项目的子项目。HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。另一个不同的是HBase基于列的而不是基于行的模式。 Memcaced数据库&nbsp;&nbsp;Memcaced是一个开源的、高性能的、具有分布式内存对象的缓存系统。通过它可以减轻数据库负载，加速动态的web应用，最初版本由LiveJoumal 的Brad Fitzpatrick在2003年开发完成。目前全球有非常多的用户都在使用它来架构主机的大负载网站或提升主机的高访问网站的响应速度。注意：Memcache 是这个项目的名称，而Memcached是服务端的主程序文件名。&nbsp;&nbsp;缓存一般用来保存一些进程被存取的对象或数据，通过缓存来存取对象或数据要比在磁盘上存取块很多，前者是内存，后者是磁盘、Memcached是一种纯内存缓存系统，把经常存取的对象或数据缓存在memcached的内存中，这些被缓存的数据被程序通过API的方式被读取，memcached里面的数据就像一张巨大的hash表，数据以key-value对的方式存在。Memcached通过缓存经常被存取的对象或数据，从而减轻频繁读取数据库的压力，提高网站的响应速度，构建出快速更快的可扩展的Web应用。 以上详细介绍可参考 常见的主流数据库（DBMS）-柚子君. 上一篇中已经给大家讲解了如何安装SqlServer2012以及简单的使用,视频请按照 网易云课堂 相关提示观看 下一篇准备给大家讲讲SqlServer2012管理工具的详细使用及相关约束的建立 彩蛋–&gt;准备近期开设一个专栏,发布往届小哥哥小姐姐的个人总结或者博客,当然欢迎大家积极投稿(md文档)","link":"/2020/02/09/SqlServer/SqlServer%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"SqlServer中企业管理器的使用","text":"SQL基础系列课程-SqlServer中企业管理器的使用 @程序猿付显 同学们请注意,视频已经录制完毕,已上传到网易云课堂,组织统一时间观看并完成相关作业 使用企业管理器管理数据库文件及文件组&nbsp;&nbsp;安装好 SQL Server 2012 数据库服务器，然后需要将一些数据存放到数据库中， 那么我们应该怎么做呢？ &nbsp;&nbsp;就是在 SQL Server 2012 数据库服务器上创建一个数据库用来存放数据。这个新数据库以文件形式存放在计算机的硬盘中。 &nbsp;&nbsp;在 SQL Server中一个数据库至少包含两种文件——数据库文件和事务日志文件。一个数据库至少应包含一个数据库文件和一个事务日志文件。 1．数据库文件(Database File)&nbsp;&nbsp;数据库文件是存放数据库数据和数据库对象的文件，一个数据库可以有一个或多个数据库文件，一个数据库文件只属于一个数据库；当有多个数据库文件时，有一个文件被定义为主数据库文件(Primary Database File)，扩展名为.mdf，它用来存储数据库的启动信息和部分或全部数据；一个数据库只能有一个主数据库文件，其他数据库文件被称为次数据库文件(Secondary Database File)，扩展名为.ndf，用来存储 主文件没有存储的其他数据。&nbsp;&nbsp;采用多个数据库文件来存储数据的优点体现在如下两个方面: 数据库文件可以不断扩充而不受操作系统文件大小的限制 可以将数据库文件存储在不同的硬盘中，这样可以同时对几个硬盘做数据 存取，提高数据处理效率 2. 事务日志文件(Transaction Log File)&nbsp;&nbsp;事务日志文件是用来记录数据库更新情况的文件，扩展名为.ldf，对数据库进行的操作都会记录在此文件中 3. 文件组(File Group)&nbsp;&nbsp;文件组是将多个数据库文件集合起来形成的一个整体，每个文件组有一个组名。 与数据库文件一样，文件组也分为主文件组(Primary File Group)和次文件组 (Secondary File Group)。主数据库文件必须放在主文件组中，次数据库文件可以放 在次文件组 创建数据库&nbsp;&nbsp;在企业管理器中创建数据库 1、 在企业管理器的“数据库”的快捷菜单中右击 “新建数据库” 2、 按照需求设定各种属性的值，包括文件类型、文件组、初始大小、自动增长以及存储路径。 在 SQL Server 2012中，自动增长可以按照百分比和 MB两种方式增长。 3、点击确定就完成了创建数据库。 配置数据库属性&nbsp;&nbsp;在创建的数据库上右键，选中“属性”，然后选择“选项” ANSI Null 默认值。允许在数据库表的列中输入 Null 值。 只读。数据库只读，只能查看不能修改。 自动关闭。当数据库中无用户时，自动关闭此数据库并将释放所占用的资 源；对那些经常被使用的数据库，不要使用此选项，否则会额外增加开关 数据库的次数而带来负担。 自动收缩。定期对数据库进行检查，当数据库文件或日志文件的未使用空 间超过其大小的 25%时，系统将会自动收缩文件，使其未用空间等于 25%， 当文件大小没有超过其建立时的初始大小时不会缩减；文件缩减后也必须 大于或等于其初始大小。 删除数据库&nbsp;&nbsp;在 SQL Server Management Studio 中可以很简单的完成：在需要删除的数据库上右击，然 后选择“删除”选项，就会弹出删除的对话框，单击“确定”按钮即可 分离、附加数据库 通过分离数据库会将数据库在本机上分离，通过分离会形成多个文件，以便使用 通过附加数据库将我们分离后的文件附加进数据库管理工具中。 使用企业管理器管理表数据类型 创建表 使用企业管理器管理约束数据完整性&nbsp;&nbsp;数据完整性（Data Integrity）是指数据的精确性（Accuracy） 和可靠性（Reliability）它是应防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。 1、实体完整性 实体完整性指表中行的完整性。 2、域完整性 域完整性能够保证表中的数据是合法的数据。 3、引用完整性（参照完整性） 引用完整性是指某列的值必须与其他列的值匹配。 创建约束主键约束 检查约束 外键约束 默认约束 标识列 列值是否为空 唯一约束 导出SQL文件 本章给大家讲解了工具的简单使用我们的重点在下一章 下一章使用查询分析器来管理数据库、表、约束等 等大家把下一章学会你们会回过头来认真学习本章内容的，不要问为什么！","link":"/2020/02/12/SqlServer/SqlServer%E4%B8%AD%E4%BC%81%E4%B8%9A%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"Spring 依赖注入的三种形式","text":"小哥哥小姐姐【转载】-Spring 依赖注入的三种形式 @孟某人 Spring 依赖注入的三种形式第一种：构造函数注入 所使用标签:constructor-arg 标签出现的位置：bean标签的内部 标签中的属性: type：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型 index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引的位置是从0开始 name：用于指定给构造函数中指定名称的参数赋值 —————-常用的以上三个属性用于指定给构造函数中哪个参数赋值，以下两个用于赋值 value：用于提供基本类型和String类型的数据 ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象 优势：在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。 弊端：改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。 1234567&lt;bean id=\"accountService\" class=\"com.msg.service.AccountServiceImpl\"&gt; &lt;constructor-arg name=\"name\" value=\"泰斯特\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"age\" value=\"18\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"birthday\" ref=\"now\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- 配置一个日期对象以供birthday属性引用 --&gt; &lt;bean id=\"now\" class=\"java.util.Date\"&gt;&lt;/bean&gt; 第二种：set方法注入(相比于构造函数注入，set方式注入更为常用) 所使用标签:==property== 标签出现的位置：bean标签的内部 标签中的属性与使用方法: name：用于指定注入时所调用的set方法名称 value：用于提供基本类型和String类型的数据 ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象1234567&lt;bean id=\"accountService2\" class=\"com.msg.impl.AccountServiceImpl2\"&gt; &lt;property name=\"name\" value=\"TEST\" &gt;&lt;/property&gt; &lt;property name=\"age\" value=\"21\"&gt;&lt;/property&gt; &lt;property name=\"birthday\" ref=\"now\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置一个日期对象以供birthday属性引用 --&gt; &lt;bean id=\"now\" class=\"java.util.Date\"&gt;&lt;/bean&gt; 在==property==标签中注入array(数组) Map List Set属性时都有相应的标签与之对应使用方法如下： (结构相同，标签可以互换就比如为数组注入可以使用list或set标签注入) 123456789101112131415161718192021222324252627282930313233&lt;bean id=\"accountService3\" class=\"com.msg.impl.AccountServiceImpl3\"&gt;&lt;!--数组注入--&gt; &lt;property name=\"myarray\"&gt; &lt;array&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;!--list注入--&gt; &lt;property name=\"myList\"&gt; &lt;list&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;!--set注入--&gt; &lt;property name=\"mySet\"&gt; &lt;set&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/set&gt; &lt;/property&gt;&lt;!--set注入--&gt; &lt;property name=\"myMap\"&gt; &lt;map&gt; &lt;entry key=\"testC\"&gt;ccc&lt;/prop&gt; &lt;entry key=\"testD\"&gt;ddd&lt;/prop&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; 优势： 创建对象时没有明确的限制，可以直接使用默认构造函数 弊端： 如果有某个成员必须有值，则获取对象是有可能set方法没有执行。 第三种：注解注入 首先介绍一下bean的常用属性配置： 1&lt;bean id=\"\" class=\"\" scope=\"\" init-method=\"\" destroy-method=\"\"&gt;&lt;/bean&gt; id：id的值是我们通过ApplicationContext容器获取对象时的依据(唯一的) class：值为 类的全限定地址 init-method：值为类初始化所执行的方法名 destroy-method：值为类的销毁时所执行的方法 scope:用于指定bean的作用范围取值： 常用的就是单例的和多例的 singleton：单例的（默认值） prototype：多例的 request：作用于web应用的请求范围 session：作用于web应用的会话范围 global-session：作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session 下面我们来介绍注解： 注解的作用： 和在XML配置文件中编写一个标签实现的功能是一样的只不过配置的方式不同 用于把当前类对象存入spring容器中注解 @Component: - 作用：将当前标注的类对象存入Spring容器中 属性： value：用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写 。 @Component衍生的注解：（以下三个注解他们的作用和属性与Component是一模一样，他们三个是spring框架为我们提供明确的三层使用的注解，使我们的三层对象更加清晰） @Controller：一般用在表现层 @Service：一般用在业务层 @Repository：一般用在持久层 用于注入数据的注解 作用：他们的作用就和在xml配置文件中的bean标签中写一个标签的作用是一样的 @Autowired注解: 作用：自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功， 如果ioc容器中没有任何bean的类型和要注入的变量类型匹配，则报错。如果Ioc容器中有多个类型匹配时则需要@Qualifier注解配合使用 出现位置：可以是变量上，也可以是方法上 细节：在使用注解注入时，set方法就不是必须的了。 @Qualifier注解: 作用：在按照类中注入的基础之上再按照名称注入。它在给类成员注入时不能单独使用要与@Autowired注解的配合下使用。但是在给方法参数注入时可以 属性：value：用于指定注入bean的id。 @Resource注解(推荐使用) 作用：直接按照bean的id注入。它可以独立使用 属性：name：用于指定bean的id。 @Value注解 作用：用于注入基本类型和String类型的数据 属性：value：用于指定数据的值。它可以使用spring中SpEL(也就是spring的el表达式）SpEL的写法：${表达式} 另外，集合类型的注入只能通过XML来实现。 用于改变作用范围的注解 @Scope注解 作用：他们的作用就和在bean标签中使用scope属性实现的功能是一样的指定bean的作用范围 属性：value：指定范围的取值。常用取值：singleton(默认单例) prototype(多例) 和生命周期相关的注解 @PreDestroy注解 作用：用于指定销毁方法(和在bean标签中destroy-methode的作用是一样的) @PostConstruct注解 作用：用于指定初始化方法(和在bean标签中init-method的作用是一样的)联系我","link":"/2020/02/13/%E5%B0%8F%E5%93%A5%E5%93%A5%E5%B0%8F%E5%A7%90%E5%A7%90%E7%B3%BB%E5%88%97/Spring%20%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E5%BD%A2%E5%BC%8F/"},{"title":"Java中的常用类(一)","text":"Java高级系列课程-Java中的常用类(一) @程序猿付显 包装类什么是包装类?ByteBooleanCharacterShort Integer LongFloat Double 都是包装类 包装类有什么作用?Java语言是面向对象的语言,但是Java中基本数据类型却不是面向对象的,即不能使用Object类提供的一些方法,比如toString()等,也不具备面向对象的一些特征不能参与转型、泛型、反射等过程，同样也不能参与到集合的操作中，所以为了弥补这些缺点，Java提供了包装类。 包装类都有哪些？ 基本类型 包装类型 byte Byte boolean Boolean char Character short Short int Integer long Long float Float double Double 包装类怎么用基本数据类型 –&gt; 包装类型 此过程被称为 装箱包装类型 –&gt; 基本数据类型 此过程被称为 拆箱 int的包装类Integer123456789101112131415161718192021// int Integerint a = 7;Integer b = new Integer(7);Integer c = new Integer(\"7\");System.out.println(a); // 7System.out.println(b); // 7System.out.println(c); // 7// int 和 Integer相互转换// int --&gt; Integer 装箱操作Integer i1 = new Integer(9);// 装箱操作Integer i2 = 5;// 自动装箱操作// Integer --&gt; int 拆箱操作int i3 = i1.intValue(); // 拆箱操作int i4 = i2;// 自动拆箱操作System.out.println(i1);System.out.println(i2);System.out.println(i3);System.out.println(i4); byte的包装类Byte12345678910111213141516171819202122byte b = 3;Byte b2 = 3;Byte b3 = new Byte((byte) 3);Byte b4 = new Byte(\"3\");System.out.println(b);System.out.println(b2);System.out.println(b3);System.out.println(b4);// byte Byte 相互转换// byte --&gt; Byte 装箱操作Byte b5 = new Byte((byte) 8);//装箱操作Byte b6 = (byte) 8;//自动装箱操作//Byte --&gt; byte 拆箱操作byte b7 = b5.byteValue();//拆箱操作byte b8 = b6;//自动拆箱操作System.out.println(b5);System.out.println(b6);System.out.println(b7);System.out.println(b8); boolean的包装类Boolean12345678910111213141516171819202122boolean b = false;Boolean b2 = false;Boolean b3 = new Boolean(false);Boolean b4 = new Boolean(\"false\");System.out.println(b);System.out.println(b2);System.out.println(b3);System.out.println(b4);//boolean 和Boolean相互转换//boolean --&gt; Boolean装箱操作Boolean b5 = new Boolean(false);//装箱操作Boolean b6 = false;//自动装箱操作//Boolean --&gt; boolean 拆箱操作boolean b7 = b5.booleanValue();//拆箱操作boolean b8 = b6;//自动拆箱操作System.out.println(b5);System.out.println(b6);System.out.println(b7);System.out.println(b8); 其余的几个道理是一样,大家可以参看api文档. String类常用的写法String 类是一个字符类,也是我们常用的一个类,我们一般存储各种各样的字符数据常用写法: 1String str = \"这是一个字符串\"; 除了这样的写法还有: 1String str = new String(\"这是一个类该有的创建对象的方式\"); 实际上字符串在String内部是通过一个char[]数组表示的，因此，按下面的写法也是可以的: 1String str = new String(new char[]{'这','是','一','种','创','建','方','式'}); 因为String太常用了,所以Java提供了第一种字面量表示的方式String 类内部通过private final char[] 这样的方式以及没有提供任何修改char[]的方法实现的,所以字符串具有不变性,也就是我们通常说的字符串不可变 常用的方法:char charAt(int index) 返回指定index处的char值 1234String str = \"这是第一个测试字符串\";char c1 = str.charAt(0);//这char c2 = str.charAt(1);//是char c3 = str.charAt(2);//第 String concat(String str) 将指定的字符串str连接到当前字符串的末尾,并返回此新字符串对象 1234String name = \"付显\";String newName = name.concat(\"-老师\");System.out.println(name);//付显System.out.println(newName);//付显-老师 boolean contains(CharSequence s) 此字符串对象是否包含指定的字符序列(一般可以认为是字符串) 123String str = \"abcdefghijkfuxianlmnopk\";boolean isContains = str.contains(\"fuxian\")System.out.println(isContains);//true boolean startsWith(String prefix) 此字符串是否以指定的前缀开头boolean endsWith(String suffix) 此字符串是否以指定的后缀结尾 12345String str = \"这是一个文本文件.txt\";boolean b1 = str.startsWith(\"t\");//falseboolean b2 = str.startsWith(\"这是\");//trueboolean b3 = str.endsWith(\"txt\");//trueboolean b4 = str.endsWith(\"t\");//true boolean equals(Object anObject) 对比此字符串对象与指定对象的内容进行比对 123456String str = \"这是第一个字符串\";String str2 = \"这是第二个字符串\";String str3 = new String(\"这是第一个字符串\");System.out.println(str.equals(str2));//falseSystem.out.println(str.equals(str3));//trueSystem.out.println(str2.equals(str3));//false boolean equalsIgnoreCase(String anotherString) 对比此字符串对象与指定内容进行忽略大小写的比对 1234String str = \"abcd\";String str2 = \"aBCd\";System.out.println(str.equals(str2));//falseSystem.out.println(str.equalsIgnoreCase(str2));//true int indexOf(int ch) 返回指定字符在字符串对象中首次出现的索引int indexOf(String str) 返回指定字符串在字符串对象中首次出现的索引int lastIndexOf(int ch) 返回指定字符在字符串对象中最后一次出现的索引int lastIndexOf(String str) 返回指定字符串在字符串对象中最后一次出现的索引 12345String str = \"我是一个测试字符串,这是真的字符串\";System.out.println(str.indexOf('串'));//8System.out.println(str.indexOf(\"字符串\"));//6System.out.println(str.lastIndexOf('串'));//16System.out.println(str.lastIndexOf(\"字符串\"));//14 int length() 返回此字符串的长度boolean isEmpty() 此字符串是否为空串 123456String str = \"\";String str1 = \"这不是空串\";System.out.println(str.length());//0System.out.println(str1.length());//5System.out.println(str.isEmpty());//trueSystem.out.println(str1.isEmpty());//false String replace(char oldChar, char newChar) 返回使用newChar替换oldChar之后的新String对象String replace(CharSequence oldString, CharSequence newString) 返回使用oldString替换newString之后的新String对象 123456String str = \"付显是个Java程序猿!\";String newStr = str.replace('猿','员');String newStr2 = str.replace(\"Java\",\"C#\");System.out.println(str);//付显是个Java程序猿!System.out.println(newStr);//付显是个Java程序员!System.out.println(newStr2);//付显是个C#程序员! String[] split(String regex) 按照给定的字符串或者正则表达式进行字符串的分割 12345678910String str =\"年年岁岁花相似,岁岁年年人不同!\";String[] strs = str.split(\"岁\");for (String s : strs) { System.out.println(s);//{\"年年\",\"\",\"花相似,\",\"\",\"年年人不同!\"}}String[] strs2 = str.split(\"岁岁\");for (String s : strs2) { System.out.println(s);//{\"年年\",\"花相似,\",\"年年人不同!\"}} String substring(int beginIndex) 返回指定起始位置的字符串String substring(int beginIndex,int endIndex) 返回指定起始位置,指定结束位置的字符串 123String str =\"年年岁岁花相似,岁岁年年人不同!\";System.out.println(str.substring(3));//岁花相似,岁岁年年人不同!System.out.println(str.substring(3, 10));//岁花相似,岁岁 String toLowerCase() 返回此字符串的小写字符String toUpperCase() 返回此字符串的大写字符 123String str =\"Hello World!\";System.out.println(str.toLowerCase());//hello world!System.out.println(str.toUpperCase());//HELLO WORLD! String trim() 返回去掉字符串前后所有空格的新字符串 123String str =\" Hello World! \";System.out.println(str);//\" Hello World! \"System.out.println(str.trim());//\"Hello World!\" static String valueOf(…) 将参数内容转换成String对象 123456Integer i = new Integer(4);char[] charArray = {'H','e','l','l','o',' ','w','o','r','l','d','!'};String s =String.valueOf(i);String s2 =String.valueOf(charArray);System.out.println(s);//4System.out.println(s2);//Hello world! String int Integer相互转换String –&gt; int12String str = \"123\";int i = Integer.parseInt(str); String –&gt; Integer123String str = \"123\";Integer i = new Integer(str)Integer i2 = Integer.valueOf(str); int –&gt; Integer123int i = 123;Integer i2 = i;Integer i3 = new Integer(i); int –&gt; String123int i = 123;String s1 = i + \"\";String s2 = String.valueOf(i); Integer –&gt; int123Integer i = new Integer(123);int i2 = i;int i3 = i.intValue(); Integer –&gt; String123Integer i = new Integer(123);String s1 = i + \"\";String s2 = String.valueOf(i); StringBuffer类在实际工作中,我们会经常用到字符串相关操作,由此带来一个问题,而且这个问题还比较严重,由于字符串的不变性,所以在操作字符串时不管是新增删除替换等任何操作都会产生新的字符串对象,如果这个操作的数量级非常大,那对于系统内存的消耗是非常大的,也拖延了程序的执行时间,所以为了解决这个问题,出现了StringBuffer类–字符串缓冲类此类还提供了链式的访问模式: 123456StringBuffer sb = new StringBuffer();for (int i = 0; i &lt; 1000; i++) { sb.append(','); sb.append(i);}String s = sb.toString(); append 方法的返回值为 this 即当前对象,所以可以继续使用此方法的返回值继续调用其他相关方法 StringBuilder类StringBuilder类也代表可变字符串对象。实际上，StringBuilder和StringBuffer基本相似，两个类的构造器和方法也基本相同。不同的是：StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能略高。 123456StringBuilder sb = new StringBuilder();for (int i = 0; i &lt; 1000; i++) { sb.append(','); sb.append(i);}String s = sb.toString(); StringBuffer 类中的方法都添加了 synchronized 关键字进行加锁,所以在多线程中使用StringBuffer更安全,在单线程中使用StringBuilder性能更高。","link":"/2020/03/11/java/Java%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E7%B1%BB(%E4%B8%80)/"},{"title":"Java中的常用类(二)","text":"Java高级系列课程-Java中的常用类(二) @程序猿付显 Date类Date类是我们常用的一个日期和时间的对象,此类在 java.util 包中,并不是java.sql中的Date,java.sql.Date 类是数据库中使用的一个日期类型,我们需要加以区分.Date类源码中可以发现它实际上存储了一个long类型的以毫秒表示的时间戳： 12345public class Date implements java.io.Serializable, Cloneable, Comparable&lt;Date&gt;{ private transient long fastTime; ... } 实例化Date对象: 1234Date date = new Date();Date date2 = new Date(System.currentTimeMillis());System.out.println(date);System.out.println(date2); Date对象的使用 123456789System.out.println(date.getYear() + 1900); // 必须加上1900System.out.println(date.getMonth() + 1); // 0~11，必须加上1System.out.println(date.getDate()); // 1~31，不能加1// 转换为String:System.out.println(date.toString());// 转换为GMT时区:System.out.println(date.toGMTString());// 转换为本地时区:System.out.println(date.toLocaleString()); Calendar类日历类Calendar更多的是代表年 月 日 周 星期 上午 下午 夏时令等这样内容,Date用于记录某一个含日期的、精确到毫秒的时间。重点在代表一刹那的时间本身 Calendar实例对象的创建方式: 1Calendar calendar = Calendar.getInstance(); Calendar 常用的方法 1234567891011Calendar calendar = Calendar.getInstance();//通过Calendar 方法获取一个Date 的实例Date date = calendar.getTime();//Calendar 方法获取年月日的方法：int year =calendar.get(Calendar.YEAR);int month=calendar.get(Calendar.MONTH)+1;int day =calendar.get(Calendar.DAY_OF_MONTH);int hour =calendar.get(Calendar.HOUR_OF_DAY);int minute =calendar.get(Calendar.MINUTE);int seconds =calendar.get(Calendar.SECOND); SimpleDateFormat类我们看到上边两个类可以解决我们的日期及时间问题,但是好像并不能友好的显示时间及日期我们期望输出: 12020年03月10日 15:01:03 可 Date 输出的是: 1Tue Mar 10 15:02:06 CST 2020 虽然也有上边的格式输出,但是方法已经被废弃了,不再使用了.那为了解决这个问题就出现了SimpleDateFormat类,专门处理日期类型的格式化输出问题. SimpleDateFormat提供了将Date转换成String的一些预定义字符串表示格式: 123456yyyy：年MM：月dd: 日HH: 小时mm: 分钟ss: 秒 我们来看如何以自定义的格式输出： 1234// 获取当前时间:Date date = new Date();SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\");System.out.println(sdf.format(date)); *JDK 1.8新增的日期时间类LocalDate类本地日期类 LocalTime类本地时间类 LocalDateTime类本地日期时间类 1234567891011121314151617181920212223LocalDate d = LocalDate.now(); // 当前日期LocalTime t = LocalTime.now(); // 当前时间LocalDateTime dt = LocalDateTime.now(); // 当前日期和时间System.out.println(d); // 严格按照ISO 8601格式打印System.out.println(t); // 严格按照ISO 8601格式打印System.out.println(dt); // 严格按照ISO 8601格式打印//另一种比较规范的用法LocalDateTime dt = LocalDateTime.now(); // 当前日期和时间LocalDate d = dt.toLocalDate(); // 转换到当前日期LocalTime t = dt.toLocalTime(); // 转换到当前时间System.out.println(d); // 严格按照ISO 8601格式打印System.out.println(t); // 严格按照ISO 8601格式打印System.out.println(dt); // 严格按照ISO 8601格式打印System.out.println(dt.getYear());//年份System.out.println(dt.getMonth());//月份System.out.println(dt.getDayOfMonth());//一个月中的第几天System.out.println(dt.getDayOfWeek());//一周中的星期几System.out.println(dt.getDayOfYear());//一年中的第几天System.out.println(dt.getHour());//小时System.out.println(dt.getMinute());//分钟System.out.println(dt.getSecond());//秒 还可以通过指定的日期和时间创建LocalDate LocalTime LocalDateTime 对象: 123456789// 指定日期和时间:LocalDate date = LocalDate.of(2020, 03, 10); // 2020-03-10, 注意03=3月LocalTime time = LocalTime.of(15, 16, 17); // 15:16:17LocalDateTime dateTime1 = LocalDateTime.of(2020, 03, 10, 15, 16, 17);LocalDateTime dateTime2 = LocalDateTime.of(date, time);System.out.println(date);System.out.println(time);System.out.println(dateTime1);System.out.println(dateTime2); 同样可以通过标准格式创建对象: 123456LocalDateTime dateTime = LocalDateTime.parse(\"2020-03-10T15:16:17\");LocalDate date = LocalDate.parse(\"2020-03-10\");LocalTime time = LocalTime.parse(\"15:16:17\");System.out.println(dateTime);System.out.println(date);System.out.println(time); ISO 8601规定的日期和时间格式: 12345日期：yyyy-MM-dd时间：HH:mm:ss带毫秒的时间：HH:mm:ss.SSS日期和时间：yyyy-MM-dd'T'HH:mm:ss带毫秒的日期和时间：yyyy-MM-dd'T'HH:mm:ss.SSS *JDK 1.8新增日期格式化 DateTimeFormatter类如果要自定义输出的格式，或者要把一个非ISO 8601格式的字符串解析成LocalDateTime，可以使用新的DateTimeFormatter： 1234567// 自定义格式化:DateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyy/MM/dd HH:mm:ss\");System.out.println(dtf.format(LocalDateTime.now()));// 用自定义格式解析:LocalDateTime dt2 = LocalDateTime.parse(\"2020/03/10 15:16:17\", dtf);System.out.println(dt2); System类System是一个类，这个System类主要是一些与系统相关的属性和方法的集合，而且其内部的方法全部是静态的，所以我们直接使用System直接调用就好.常用的方法: 1234567891011//输出System.out.println(\"test\");//输入System.in;//获取当前时间的时间戳System.currentTimeMillis();//垃圾回收System.gc(); Scanner类Scanner是一个基于正则表达式的文本扫描器~~可以从文件，输入流，字符串中解析出基本类型和字符串类型的值。Scanner类提供了多个构造器，不同的构造器可以接受文件，输入流，字符串作为数据源，用于从文件，输入流字符串中解析数据。Scanner除了可以获取键盘输入外，也可以获取文件中的内容，将文件中的内容一行一行的输入出来 Scanner 常用的一种形式: 1Scanner scan = new Scanner(System.in); 常用的方法: next()12345678910Scanner scan = new Scanner(System.in);// 从键盘接收数据// next方式接收字符串System.out.println(\"next方式接收：\");// 判断是否还有输入if (scan.hasNext()) { String str1 = scan.next(); System.out.println(\"输入的数据为：\" + str1);}scan.close(); nextLine()12345678910Scanner scan = new Scanner(System.in);// 从键盘接收数据// nextLine方式接收字符串System.out.println(\"nextLine方式接收：\");// 判断是否还有输入if (scan.hasNextLine()) { String str2 = scan.nextLine(); System.out.println(\"输入的数据为：\" + str2);}scan.close(); next() 与 nextLine() 区别next():1、一定要读取到有效字符后才可以结束输入。2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。4、next() 不能得到带有空格的字符串。 nextLine()：1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。2、可以获得空白。 如果要输入 int 或 float 类型的数据，在 Scanner 类中也有支持，但是在输入之前最好先使用 hasNextXxx() 方法进行验证，再使用 nextXxx() 来读取： 12345678910111213141516171819202122232425Scanner scan = new Scanner(System.in);// 从键盘接收数据int i = 0;float f = 0.0f;System.out.print(\"输入整数：\");if (scan.hasNextInt()) { // 判断输入的是否是整数 i = scan.nextInt(); // 接收整数 System.out.println(\"整数数据：\" + i);} else { // 输入错误的信息 System.out.println(\"输入的不是整数！\");}System.out.print(\"输入小数：\");if (scan.hasNextFloat()) { // 判断输入的是否是小数 f = scan.nextFloat(); // 接收小数 System.out.println(\"小数数据：\" + f);} else { // 输入错误的信息 System.out.println(\"输入的不是小数！\");}scan.close(); Math类Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** *Math.sqrt()//计算平方根 *Math.cbrt()//计算立方根 *Math.pow(a, b)//计算a的b次方 *Math.max( , );//计算最大值 *Math.min( , );//计算最小值 */ System.out.println(Math.sqrt(16)); //4.0 System.out.println(Math.cbrt(8)); //2.0 System.out.println(Math.pow(3,2)); //9.0 System.out.println(Math.max(2.3,4.5));//4.5 System.out.println(Math.min(2.3,4.5));//2.3 /** * abs求绝对值 */ System.out.println(Math.abs(-10.4)); //10.4 System.out.println(Math.abs(10.1)); //10.1 /** * ceil天花板的意思，就是返回大的值 */ System.out.println(Math.ceil(-10.1)); //-10.0 System.out.println(Math.ceil(10.7)); //11.0 System.out.println(Math.ceil(-0.7)); //-0.0 System.out.println(Math.ceil(0.0)); //0.0 System.out.println(Math.ceil(-0.0)); //-0.0 System.out.println(Math.ceil(-1.7)); //-1.0 /** * floor地板的意思，就是返回小的值 */ System.out.println(Math.floor(-10.1)); //-11.0 System.out.println(Math.floor(10.7)); //10.0 System.out.println(Math.floor(-0.7)); //-1.0 System.out.println(Math.floor(0.0)); //0.0 System.out.println(Math.floor(-0.0)); //-0.0 /** * random 取得一个大于或者等于0.0小于不等于1.0的随机数 */ System.out.println(Math.random()); //小于1大于0的double类型的数 System.out.println(Math.random()*2);//大于0小于1的double类型的数 System.out.println(Math.random()*2+1);//大于1小于2的double类型的数 /** * rint 四舍五入，返回double值 * 注意.5的时候会取偶数 异常的尴尬=。= */ System.out.println(Math.rint(10.1)); //10.0 System.out.println(Math.rint(10.7)); //11.0 System.out.println(Math.rint(11.5)); //12.0 System.out.println(Math.rint(10.5)); //10.0 System.out.println(Math.rint(10.51)); //11.0 System.out.println(Math.rint(-10.5)); //-10.0 System.out.println(Math.rint(-11.5)); //-12.0 System.out.println(Math.rint(-10.51)); //-11.0 System.out.println(Math.rint(-10.6)); //-11.0 System.out.println(Math.rint(-10.2)); //-10.0 /** * round 四舍五入，float时返回int值，double时返回long值 */ System.out.println(Math.round(10.1)); //10 System.out.println(Math.round(10.7)); //11 System.out.println(Math.round(10.5)); //11 System.out.println(Math.round(10.51)); //11 System.out.println(Math.round(-10.5)); //-10 System.out.println(Math.round(-10.51)); //-11 System.out.println(Math.round(-10.6)); //-11 System.out.println(Math.round(-10.2)); //-10 Random类Java中的Random类主要用来生成随机数 123456Random random=new Random();//以系统当前时间作为随机数生成的种子 System.out.println(random.nextInt(10));//返回一个大于0且小于10的整数 System.out.println(random.nextFloat()); //返回一个随机浮点型 System.out.println(random.nextBoolean()); //返回一个随机布尔型值 System.out.println(random.nextDouble()); //返回一个随机双精度型 System.out.println(random.nextLong()); //返回一个随机长整形","link":"/2020/07/13/java/Java%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E7%B1%BB(%E4%BA%8C)/"},{"title":"Java中的面向对象","text":"Java高级系列课程-Java中的面向对象 @程序猿付显 一、面向对象面向对象的思想 二、类的定义Java中对于类的定义 三、对象的创建及使用对象创建使用new关键字 四、构造方法没有返回值一说,方法名和类名相同的方法 五、this关键字this代表当前对象 六、方法的重载一个类中方法名相同,参数的个数或者类型不同,这就叫做方法的重载 七、static关键字static修饰的变量称之为静态变量static修饰的方法称之为静态方法静态变量使用 类名.变量名进行访问静态方法使用 类名.方法名进行调用","link":"/2020/03/11/java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"title":"Java中的集合框架与泛型","text":"Java高级系列课程-Java中的集合框架与泛型 @程序猿付显 集合概述什么是集合(Collection)?–集合就是”由若干个确定的元素所构成的整体”.集合是存储对象的容器，可以存储任意数量、任意类型的对象。在数学中,我们经常遇到集合的概念.例如: 有限集合: 一个班所有的同学构成的集合 一个网站所有的商品构成的集合 . . . 无限集合: 全体自然数集合:1 2 3 … 有理数集合 实数集合 . . . 为什么要引入集合呢?就是为了方便统一处理一组类似或者相同类型的数据.例如: 计算所有同学的总成绩和平均成绩 列举出京东商城上所有的商品名称和价格 . . . 在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。很显然，Java的数组可以看作是一种集合.说到这个地方我们会发现我们之前学习的数组就可以完成这些功能或者说是满足我们目前的需求的. 123String[] ss = new String[10]; // 可以持有10个String对象ss[0] = \"Hello\"; // 可以放入String对象String first = ss[0]; // 可以获取String对象 既然Java提供了数组这种数据类型，可以充当集合，那么，我们为什么还需要其他集合类？这是因为数组有如下限制： 数组初始化后大小不可变； 数组只能按索引顺序存取。 因此，我们需要各种不同类型的集合类来处理不同的数据，例如： 可变大小的顺序链表； 保证无重复元素的集合； … 集合也有一些特殊的地方:集合存储的长度可变集合只能存储对象(因为集合实际上存储的是对象的引用值也就是在堆中的地址,所以不能存放基本数据类型数据,必须经过包装类才可以存储) Collection接口Java提供了两种类型的集合接口Collection和Map,这两种都在java.util包下Collection是除Map外所有其他集合类的根接口Collection接口提供了2个子接口,List接口和Set接口同时也提供了一些通用的方法,通过这些方法可以实现对集合的基本操作 List接口List接口继承自Collection接口,它规定实现它的类存储的是有序的、不唯一的集合元素,同时提供了具体的实现类ArrayList和LinkedListArrayList:数组形式,连续的存储空间,查询速度快,增删速度慢LinkedList:双向链表,不连续的存储空间,增删速度快,查询速度慢 ArrayList类ArrayList类实现了List接口，是基于动态数组的类，可存储null值ArrayList类基于动态数组实现，因此对于随机访问或遍历速度快（查询）；对于增加和删除元素速度慢（中间一个被删除，后面的元素全部向前移动一位），只在尾部删除和增加速度快；且可随着元素的增加，自动扩容（默认扩容50%）ArrayList类实现了List接口，因此可以使用List接口和Collention接口的方法 ArrayList 创建:1List&lt;String&gt; nameList = new ArrayList&lt;String&gt;(); ArrayList类的常用方法：boolean add(E e) 向集合中添加元素E get(int index) 返回指定索引处的元素int size() 获取此集合的长度E remove(int index) 删除指定索引处的元素,并返回被删除的元素boolean remove(E e) 删除集合中第一个出现的指定元素 123456789101112131415nameList.add(\"付显\");//向集合中添加元素nameList.add(\"张三\");//向集合中添加元素nameList.add(\"李四\");//向集合中添加元素nameList.add(\"李四\");//向集合中添加元素String name = nameList.get(0);//返回指定索引处的元素System.out.println(name);int count = nameList.size();//返回此集合的长度System.out.println(count);System.out.println(nameList.remove(0));//付显System.out.println(nameList.size());System.out.println(nameList.remove(\"李四\"));//trueSystem.out.println(nameList.size()); boolean contains(Object o) list中是否包含某个元素,返回true或者falseE set(int index,E e) 根据索引将元素数值改变(替换)int indexOf(E e) 返回在此集合中指定元素第一次出现的索引int lastIndexOf(E e) 返回在此集合中指定元素最后一次出现的索引 12345678910boolean isContains = nameList.contains(\"付显\");System.out.println(nameList.set(0, \"王五\"));System.out.println(nameList.get(0));nameList.add(\"王五\");nameList.add(\"王五\");nameList.add(\"王五\");System.out.println(nameList.indexOf(\"王五\"));System.out.println(nameList.lastIndexOf(\"王五\")); boolean isEmpty() 判断集合是否为空Object[] toArray() 将集合转换为数组void clear() 将集合中的元素全部删除 1234567System.out.println(nameList.isEmpty());String[] nameArray = (String[]) nameList.toArray();for (String str : nameArray) { System.out.println(str);}nameList.clear();System.out.println(nameList.isEmpty()); ArrayList遍历集合中元素对于ArrayList有三种方式可以遍历集合中的所有元素 第一种遍历方式:普通for循环123for (int i = 0; i &lt; nameList.size(); i++) { System.out.println(nameList.get(i));} 第二种遍历方式:foreach循环123for (String str : nameList) { System.out.println(str);} 第三种遍历方式:迭代器1234Iterator&lt;String&gt; it = nameList.iterator();while(it.hasNext()) { System.out.println(it.next());} LinkedList类LinkedList类实现了List接口，是基于双向链表的类，可存储null值LinkedList类基于双向链表实现，数据是不连续的存储空间，因此对于随机访问或遍历速度慢（移动指针，一个一个查）；对于增加和删除元素速度快（只需要修改当前元素指针的上下指向即可）；且可随着元素的增加，自动扩容（默认扩容50%） LinkedList创建:1LinkedList&lt;String&gt; linkedList = new LinkedList&lt;String&gt;(); LinkedList常用方法除了和ArrayList 具有相同的一些方法(add() clear() indexOf() …)之外还具有一些特别的方法:void addFirst(E e) 将指定元素添加到此集合的开头void addLast(E e) 将指定元素添加到此集合的末尾E getFirst() 返回此集合的第一个元素E getLast() 返回此集合的最后一个元素E removeFirst() 删除此集合中的第一个元素E removeLast() 删除此集合中的最后一个元素 123456789101112linkedList.add(\"付显\");linkedList.add(\"张三\");System.out.println(linkedList.getFirst());System.out.println(linkedList.getLast());linkedList.addFirst(\"王五\");linkedList.addLast(\"李四\");System.out.println(linkedList.getFirst());System.out.println(linkedList.getLast());linkedList.removeFirst();linkedList.removeLast();System.out.println(linkedList.getFirst());System.out.println(linkedList.getLast()); LinkedList遍历集合中元素第一种遍历方式:普通for循环123for (int i = 0; i &lt; linkedList.size(); i++) { System.out.println(linkedList.get(i));} 第二种遍历方式:foreach循环123for (String str : linkedList) { System.out.println(str);} 第三种遍历方式:迭代器1234Iterator&lt;String&gt; it = linkedList.iterator();while (it.hasNext()) { System.out.println(it.next());} Set接口Set接口继承自Collection接口，它存储的是无序的、唯一的集合元素 HashSet类HashSet类实现了Set接口，是基于HashMap实现，存储不重复、无序值HashSet是根据对象的哈希值来确定元素在集合中的存储位置的，元素在插入时就确定了存储位置，因此，元素在集合中存储的位置是固定的（无序是指输出顺序与存储顺序不一致），具有良好的存储和查找性能（存储速度快）。保证元素的唯一性依赖于hashCode方法和equals方法。 HashSet 创建1HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); HashSet 部分常用方法boolean add(E e) 向集合中添加元素int size() 获取此集合的长度boolean remove(E e) 删除集合中第一个出现的指定元素 1234567set.add(\"付显\");set.add(\"张三\");set.add(\"付显\");set.add(\"李四\");System.out.println(set.size());set.remove(\"付显\");System.out.println(set.size()); HashSet 遍历方法因为没有了get()方法,所以只有两种遍历方式 第一种遍历方式:foreach循环123for (String str : set) { System.out.println(str);} 第二种遍历方式:迭代器1234Iterator&lt;String&gt; it = set.iterator();while (it.hasNext()) { System.out.println(it.next());} Map接口Map接口是一个根接口，它存储的是键-值对（key-value），其中key不允许重复，value允许重复 HashMap类HashMap类实现了Map接口，存储的是无序的键-值对（key-value） 1.HashMap的key是用set集合来存放的，所以想做到 key不允许重复，key对应的类需要重写 hashCode和 equals 方法 2.HashMap是线程不安全的 3.HashMap中元素的位置是不定时更新的，即元素位置不是固定的 创建方式1HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); 常用方法V put(K key,V value) 将指定的键与之关联的值存入HashMap中V get(K key) 获取指定键所关联的值V remove(K key) 删除 123456789101112map.put(\"name\", \"付显\");map.put(\"sex\", \"男\");map.put(\"address\",\"河南省南阳市卧龙区\");String name = map.get(\"name\");String sex = map.get(\"sex\");String address = map.get(\"address\");System.out.println(name);System.out.println(sex);System.out.println(address);String nameValue = map.remove(\"name\");System.out.println(nameValue);System.out.println(map.get(\"name\")); 遍历方式第一种遍历方式 通过键值对Set集合遍历1234567Iterator&lt;Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();while (it.hasNext()) { Map.Entry&lt;String, String&gt; entry = (Map.Entry&lt;String, String&gt;) it.next(); String key = entry.getKey(); String value = entry.getValue(); System.out.println(key + \":\" + value);} 第二种遍历方式 通过键Set集合遍历123456Iterator&lt;String&gt; it2 = map.keySet().iterator();while (it2.hasNext()) { String key = it2.next(); String value = map.get(key); System.out.println(key + \":\" + value);} 第三种遍历方式 通过值Set集合遍历12345Iterator&lt;String&gt; it3 = map.values().iterator();while(it3.hasNext()) { String value = it3.next(); System.out.println(value);} 泛型什么是泛型泛型，即“参数化类型”。就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。泛型：把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型 为什么使用泛型 1.适用于多种数据类型执行相同的代码（代码复用） 2.泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）123456789101112131415public static void show(int i) { System.out.println(i);}public static void show(float i) { System.out.println(i);}public static void show(double i) { System.out.println(i);}public static void show(byte i) { System.out.println(i);}public static void show(String i) { System.out.println(i);} 怎么书写泛型1234//定义泛型方法.. public static &lt;T&gt; void show(T t) { System.out.println(t); } 如何使用1234show(\"字符串\");show(5);show(10.8);show(new ArrayList&lt;String&gt;());","link":"/2020/07/13/java/Java%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%8E%E6%B3%9B%E5%9E%8B/"},{"title":"项目起始","text":"2020暑期项目-在线考试系统 @程序猿付显 一、项目需求链接：https://pan.baidu.com/s/1XElErwBmg_wKpVubjocXKQ提取码：f4vp 二、项目燃尽图未完成","link":"/2020/07/13/2020%E6%9A%91%E6%9C%9F%E9%A1%B9%E7%9B%AE-%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95%E7%B3%BB%E7%BB%9F/%E9%A1%B9%E7%9B%AE%E8%B5%B7%E5%A7%8B/"},{"title":"Java中的JDBC高级知识","text":"Java高级系列课程-Java中的JDBC高级知识 @程序猿付显 带参数的PreparedStatement在基本访问数据库的步骤中提到了用Statement去执行SQL语句。这里介绍Statement的子类PreparedStatementPreparedStatement(预处理执行语句)相比其父类Statement主要有以下几个优点: 可以防止SQL注入 在特定的驱动数据库下相对效率要高 不需要频繁编译.因为已经预加载了它有三种执行方式： pstm.executeUpdate()执行更新语句，例如insert，update，delete语句，返回受影响的行数 pstm.executeQuery()执行查询语句，返回得到的结果集 pstm.execute()可以执行任意的SQL语句，如果数据库返回的第一个结果是结果集，则方法返回true，如果返回的数字，即受影响行数或者没有返回值，则方法返回false 我们发现和Statement用法类似,在PreparedStatement中我们可以设定参数,并且可以防止SQL注入的攻击 1234567891011121314151617181920212223242526272829 // 确认我们要访问 SqlServer数据// 1:加载jdbc驱动程序(项目中添加驱动包) Class.forName(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\");// 2:使用DriverManager建立到数据库的连接 Connection conn = DriverManager.getConnection(\"jdbc:sqlserver://127.0.0.1:1433;databaseName=school\", \"sa\", \"1\");// 3:准备sql语句 String sql = \"SELECT * FROM student WHERE id = ?\";// 4:使用Statement访问数据库 PreparedStatement ps = conn.prepareStatement(sql); //4.2:赋值 ps.setInt(1, 2);// 5:使用ResultSet 或者 int 接收访问数据库的反馈结果 ResultSet rs = ps.executeQuery();// 6:对结果进行输出或展示 while (rs.next()) { System.out.println(rs.getString(2)); }// 7:关闭资源 rs.close(); ps.close(); conn.close(); 事务处理默认情况下，当我们获取一个conn连接时，这个连接默认是自动提交的，也就是说，我们每执行一条sql语句，均当作一个完整的独立的事务被执行，每一个statement.execute()方法的调用都是如同一条新的begin transaction命令开始，并由一条commit命令来提交结束。我们可以通过connection的getAutoCommit()来查看当前的自动提交状态，也可以使用setAutoCommit(false)来设置手动提交，具体的使用方法有以下几部： 设置事务的起点: con.setAutoCommit(false);//设置手动提交事务 设置事务提交还是回滚 con.commit();提交事务 con.rollback();回滚事务 未进行事务处理代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243public static void main(String[] args) { Connection conn = null; PreparedStatement ps1 = null; PreparedStatement ps2 = null; try { Class.forName(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\"); conn = DriverManager.getConnection(\"jdbc:sqlserver://127.0.0.1:1433;databaseName=school\", \"sa\", \"1\"); String sql1 = \"UPDATE account SET balance = balance+? where id =?\"; String sql2 = \"UPDATE account SET balance = balance-? where id =?\"; ps1 = conn.prepareStatement(sql1); ps1.setFloat(1, 500); ps1.setInt(2, 1); int i1 = ps1.executeUpdate(); ps2 = conn.prepareStatement(sql2); ps2.setFloat(1, 500); ps2.setInt(2, 2); int i2 = ps2.executeUpdate(); System.out.println(i1 + \":\" + i2); } catch (ClassNotFoundException e) { // TODO: handle exception } catch (SQLException e) { // TODO: handle exception } finally { try { if (ps1 != null) ps1.close(); if (ps2 != null) ps2.close(); if (conn != null) conn.close(); } catch (SQLException e) { // TODO: handle exception } }} 经过添加事务之后的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static void main(String[] args) { Connection conn = null; PreparedStatement ps1 = null; PreparedStatement ps2 = null; try { Class.forName(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\"); conn = DriverManager.getConnection(\"jdbc:sqlserver://127.0.0.1:1433;databaseName=school\", \"sa\", \"1\"); //取消自动提交事务 conn.setAutoCommit(false); String sql1 = \"UPDATE account SET balance = balance+? where id =?\"; String sql2 = \"UPDATE account SET balance = balance-? where id =?\"; ps1 = conn.prepareStatement(sql1); ps1.setFloat(1, 500); ps1.setInt(2, 1); int i1 = ps1.executeUpdate(); ps2 = conn.prepareStatement(sql2); ps2.setFloat(1, 500); ps2.setInt(2, 2); int i2 = ps2.executeUpdate(); conn.commit(); System.out.println(i1 + \":\" + i2); } catch (ClassNotFoundException e) { System.out.println(\"驱动类找不到!\"); } catch (SQLException e) { try { conn.rollback(); } catch (SQLException e1) { e1.printStackTrace(); } } finally { try { if (ps1 != null) ps1.close(); if (ps2 != null) ps2.close(); if (conn != null) conn.close(); } catch (SQLException e) { System.out.println(\"关闭失败！\"); } }} 批处理JDBC API2.2开始，提供了对批处理更新的支持，这个特性是我们可以再一次数据库请求中执行多个更新语句（insert，update或者delete）。对于存在大量更新语句的情况下，采用批处理可以明显提高系统性能。 使用批处理时，可以使用PreparedStatement提供的addBatch（）方法将本条语句加入队列，所有预备语句加入完毕后，使用executeBatch（）方法一次执行这些语句，减少了数据库的负担。 批处理更新语句执行后，返回每条语句的执行结果，由于是更新语句，返回的是int值，所以多条语句将返回一个int的数组。 需要注意的是，由于批处理往往代表一个完整的操作，所以必须使用事务 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void main(String[] args) { Connection conn = null; PreparedStatement ps = null; try { Class.forName(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\"); conn = DriverManager.getConnection(\"jdbc:sqlserver://127.0.0.1:1433;databaseName=school\", \"sa\", \"1\"); // 取消自动提交事务 conn.setAutoCommit(false); String sql = \"INSERT INTO student VALUES (?,?,?)\"; ps = conn.prepareStatement(sql); for (int i = 0; i &lt; 1000; i++) { ps.setString(1, \"王五\" + i); ps.setString(2, \"wangwu\" + i); ps.setString(3, \"123456\"); ps.addBatch(); } int[] counts = ps.executeBatch(); conn.commit(); } catch (ClassNotFoundException e) { System.out.println(\"驱动类找不到!\"); } catch (SQLException e) { try { conn.rollback(); } catch (SQLException e1) { e1.printStackTrace(); } } finally { try { if (ps != null) ps.close(); if (conn != null) conn.close(); } catch (SQLException e) { System.out.println(\"关闭失败！\"); } }} 使用properties文件通过以上项目代码的书写,大家发现一个问题获取连接及之前的内容都是不会发生变化的,那这部分内容能不能简化简化? 如果数据库地址、用户名、密码、数据库类型发生变化需要修改程序源代码重新编译运行,那我们能不能只修改某些文件内容不修改源码就可以实现运行呢? 基于这些问题我们来讲解Properties类,这个类在java.util包下它提供了属性集的读取，其中属性集指属性名，属性值的组合字符串集合，类似于我们的学习的key-value结构。这个类可以直接读取文件. 在测试类同路径下新建一个info.priperties文件内容如下： 1234driver=com.microsoft.sqlserver.jdbc.SQLServerDriverurl=jdbc:sqlserver://127.0.0.1:1433;databaseName=schoolname=sapwd=1 Java代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private static String driver;private static String url;private static String name;private static String pwd; public static void main(String[] args) { initFile(); Connection conn = null; PreparedStatement ps = null; try { Class.forName(driver); conn = DriverManager.getConnection(url, name, pwd); // 取消自动提交事务 conn.setAutoCommit(false); String sql = \"INSERT INTO student VALUES (?,?,?)\"; ps = conn.prepareStatement(sql); for (int i = 0; i &lt; 1000; i++) { ps.setString(1, \"王五\" + i); ps.setString(2, \"wangwu\" + i); ps.setString(3, \"123456\"); ps.addBatch(); } int[] counts = ps.executeBatch(); conn.commit(); } catch (ClassNotFoundException e) { System.out.println(\"驱动类找不到!\"); } catch (SQLException e) { try { conn.rollback(); } catch (SQLException e1) { e1.printStackTrace(); } } finally { try { if (ps != null) ps.close(); if (conn != null) conn.close(); } catch (SQLException e) { System.out.println(\"关闭失败！\"); } } }public static void initFile() { Properties p=new Properties(); try { p.load(Test.class.getResourceAsStream(\"info.properties\")); driver=p.getProperty(\"driver\"); url=p.getProperty(\"url\"); name=p.getProperty(\"name\"); pwd=p.getProperty(\"pwd\"); } catch (IOException e) { e.printStackTrace(); } }","link":"/2020/07/13/java/Java%E4%B8%AD%E7%9A%84JDBC%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86/"},{"title":"Java中的JDBC应用实战","text":"Java高级系列课程-Java中的JDBC应用实战 @程序猿付显 实现用户的增删改查操作 需求分析我们现在需要实现一个控制台版本的学生信息信息管理系统,其中包括学生信息的列表展示、新增学生信息、修改学生信息、删除学生信息等功能。 数据库设计 字段名 类型 约束 说明 id int 主键,自增 学生ID name varchar(64) 不为空 学生姓名 sex varchar(8) 不为空 学生性别 age int 不为空 学生年龄 phone varchar(64) 不为空,唯一 学生手机号 address varchar(128) 可空 学生家庭住址 页面效果项目框架搭建DBHelper类设计MVC三层结构实体类DAO层Service层View层业务代码实现实体类实现DAO层实现View层实现测试调用View层代码","link":"/2020/07/13/java/Java%E4%B8%AD%E7%9A%84JDBC%E5%BA%94%E7%94%A8%E5%AE%9E%E6%88%98/"},{"title":"Java中的多线程","text":"Java高级系列课程-Java中的多线程 @程序猿付显 线程的概述同时执行多个操作的“思想”，在 Java 中被称为并发，而将并发完成的每一件事称为线程 进程进程：每个进程都有独立的代码和数据空间，进程是资源分配的最小单位，每个独立的程序占有一个进程 线程线程：表示程序的执行流程，是CPU调度执行的基本单位，同一类线程共享代码和数据空间，进程是线程的容器，即一个进程包含1+n个线程 每一个独立的程序都是一个进程，在计算机中的所有程序都通过CPU来执行，也就是在某个时间点上，CPU上只能运行一个程序，只是CPU运行速度非常快，在不同程序(进程)间切换所花费的时间特别短，用户才感觉好像多个进程同时在运行 多线程：每个线程完成一个功能，并与其他线程在同一个进程中并发执行，这种机制被称为多线程 多线程的优点：让程序更好的利用系统资源，不但能更好的利用系统的空闲时间，还能快速对用户的请求作出响应，使程序的运行效率大大提高，也增加了程序的灵活程度；最重要的是，可通过多线程技术解决不同任务之间的协调操作与运行、数据交互、资源分配等难题；在某些情况下使程序设计更简单。 线程的创建在Java的JDK开发包中，已经自带了对多线程技术的支持，可以方便地进行多线程编程。实现多线程编程的方式主要有两种：一种是继承Thread类，另一种是实现Runnable接口。 继承Thread类创建多线程继承Thread类来创建多线程： 定义一个继承自Thread类的子类，并重写 run()方法 创建继承Thread子类的对象 调用该线程对象的start()方法启动线程 定义一个继承自Thread类的子类 MyThread 12345678public class MyThread extends Thread { @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(this.getName() + i); } }} 12345678910public class Test01 { public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.setName(\"测试1:\"); myThread.start(); for (int i = 0; i &lt; 100; i++) { System.out.println(\"主线程:\" + i); } }} 实现Runnable接口创建多线程实现Runnable接口来创建多线程： 定义一个实现Runnable接口的子类，并重写run()方法 创建实现Runnable子类的对象 以Runnable子类的对象为参数创建Thread对象 调用Thread对象的start()方法启动线程 12345678public class MyRunnable implements Runnable { @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(\"MyRunnable中的run方法:\"+i); } }} 1234567public class Test01 { public static void main(String[] args) { MyRunnable runnable = new MyRunnable(); Thread thread = new Thread(runnable); thread.start(); }} 两种方式的对比使用继承自Thread类的方式创建多线程： 优点：编写简单，如果需要访问当前线程，直接使用 this 即可 缺点：继承自Thread类了，不能再继承其他类使用实现Runnable接口的方式创建多线程： 优点：还可以继承自其他类 缺点：编写稍微复杂，访问当前线程，需使用 Thread.currentThread() 方法 线程的生命周期在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态。当线程启动以后，它不可能一直”霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换 新建状态：当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值 就绪状态：当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行 运行状态：如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态 阻塞状态：当处于运行状态的线程失去所占用资源之后，便进入阻塞状态 死亡状态：线程在run()方法执行结束后进入死亡状态。此外，如果线程执行了interrupt()或stop()方法，那么它也会以异常退出的方式进入死亡状态。 线程的控制多线程中，当CPU在线程间切换时，需要保存线程的运行状态，再切回来时可以在之前的状态下继续执行；因此需要对线程进行良好的控制 控制线程的方式包含：判断线程是否处于活动状态，改变线程的优先级去优先执行某个线程，可中断当前线程执行其他线程等等 判断线程状态在对线程进行控制前，我们需要先判断一下线程是否处于活动状态 活动状态就是线程启动并且尚未终止；当线程处于就绪状态或者运行状态，我们就认为线程是“存活”的 123456789101112131415public class ThreadIsAlive extends Thread{ @Override public void run() { System.out.println(\"线程状态： \" + this.isAlive()); } public static void main(String[] args) { ThreadIsAlive alive = new ThreadIsAlive(); System.out.println(\"线程启动前状态： \" + alive.isAlive()); alive.start(); System.out.println(\"线程启动后状态： \" + alive.isAlive()); }} 线程优先级进程中至少有一个线程，在众多线程中，有时需要优先执行一个线程，这个线程的优先级越高，得到CPU执行的机会就越大，反之就越小 线程的优先级使用1-10之间的整数来表示，数字越大，优先级越高；除了通过整数表示优先级，还可以通过Thread类的3个静态常量表示：MAX_PRIORITY、NORM_PRIORITY、MIN_PRIORITY 123456789101112131415161718public class MyThread extends Thread{ public MyThread(String name) { super(name); } @Override public void run() { for (int i = 0; i &lt; 2; i++) { System.out.println(\"线程名称是： \" + Thread.currentThread().getName() + \"\\t线程的优先级是： \" + Thread.currentThread().getPriority() + \"\\t该线程循环执行： \" + i + \" 次\"); } }} 12345678910111213141516171819202122public static void main(String[] args) { System.out.println(\"线程名称是： \" + Thread.currentThread().getName() + \"\\t线程的优先级是： \" + Thread.currentThread().getPriority()); //创建线程 MyThread thread1 = new MyThread(\"线程1\"); MyThread thread2 = new MyThread(\"线程2\"); MyThread thread3 = new MyThread(\"线程3\"); MyThread thread4 = new MyThread(\"线程4\"); //设置线程优先级 thread1.setPriority(1); thread2.setPriority(Thread.MAX_PRIORITY); thread3.setPriority(6); thread4.setPriority(5); //启动线程 thread1.start(); thread2.start(); thread3.start(); thread4.start();} 线程中断设置线程优先级，只是增加CPU调度的机会；往往还需要直接设置线程中断，让CPU执行其他线程 sleep()可以使用静态方法sleep()方法来使正在执行的线程以指定的毫秒数暂停，进入睡眠状态，在该线程休眠时间内，CPU会调度其他线程。 12345678910111213141516171819public class MySleepThread extends Thread{ @Override public void run() { for (int i = 0; i &lt; 5; i++) { System.out.println(Thread.currentThread().getName() + \" 输出数字 ： \" + i); if (i == 3) { try { Thread.sleep(300); //将当前线程休眠300毫秒 } catch (InterruptedException e) { e.printStackTrace(); } } } } } 1234567891011121314public static void main(String[] args) throws InterruptedException{ MySleepThread thread = new MySleepThread(); thread.start(); for (int i = 0; i &lt; 5; i++) { System.out.println(Thread.currentThread().getName() + \" 输出数字 ： \" + i); if (i == 2) { Thread.sleep(200); //将当前线程休眠200毫秒 } }} yield()为了更好的操作线程，Thread类还提供了yield()方法，来暂停当前正在执行的线程对象，把机会让给相同或优先级更高的线程，因此， yield()方法也称为线程让步 123456789101112131415161718public class MyYieldThread extends Thread{ public MyYieldThread(String name) { super(name); } @Override public void run() { //循环输出，当i=3时，把线程让出来 for (int i = 0; i &lt; 5; i++) { System.out.println(Thread.currentThread().getName() + \" 输出 ： \" + i); if (i == 3) { System.out.println(\"当 i = 3时，线程让步，执行相同或更高级线程： \"); Thread.yield(); } } } 1234567public static void main(String[] args) { MyYieldThread yt1 = new MyYieldThread(\"好好学习\"); MyYieldThread yt2 = new MyYieldThread(\"天天向上\"); yt1.start(); yt2.start();} join()在多线程操作时，有时候还需要让某个线程插队，Thread类中提供了join()方法，来实现这一功能。当线程调用join()方法时，线程会进入阻塞状态，直到join方法加入的线程执行完毕，该线程才会继续执行 12345678910111213141516171819public class MyJoinThread extends Thread{ private String name; public MyJoinThread(String name) { super(name); this.name = name; } @Override public void run() { System.out.println(Thread.currentThread().getName() + \" 线程运行开始 ！\"); for (int i = 0; i &lt;= 5; i++) { System.out.println(\"线程： \" + name + \" 输出 \" + i); } System.out.println(Thread.currentThread().getName() + \" 线程运行结束 ！\"); } } 12345678910111213141516171819202122232425public static void main(String[] args) { System.out.println(Thread.currentThread().getName() + \" 线程运行开始 ！\"); //创建两个线程对象 MyJoinThread jt1 = new MyJoinThread(\"svse\"); MyJoinThread jt2 = new MyJoinThread(\"hopu\"); jt1.start(); jt2.start(); try { jt1.join(); //main线程进入等待状态，jt1插队，等jt1执行完，再等CPU调度 } catch (InterruptedException e) { e.printStackTrace(); } try { jt2.join(); //main线程进入等待状态，jt2插队，等jt2执行完，再等CPU调度 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \" 线程运行结束 ！\");} 线程的同步在多线程中，为了处理共享资源竞争，Java可以使用同步机制；所谓同步机制，指的是两个线程同时作用在一个对象上，应该保持对象数据的统一性和整体性。Java中提供了关键字synchronized，可以处理多线程同步竞争资源的问题 12345678910111213141516171819202122232425262728public class Ticketss implements Runnable{ private int tickets = 10; //定义车票10张，也可以作为编号使用 @Override public void run() { sale(); } /** * 使用synchronized修饰，使售票方法变成同步方法 */ public synchronized void sale() { while (true) { if (tickets &gt; 0) { //如果还有票，就继续售票 try { Thread.sleep(100); //当前线程睡眠100毫秒 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"窗口 \" + Thread.currentThread().getName() + \" 售出 \" + tickets--); }else { break; } } } } 1234567891011public static void main(String[] args) { //创建车票对象 Ticketss ts = new Ticketss(); new Thread(ts, \"售票员小明\").start(); new Thread(ts, \"售票员小红\").start(); new Thread(ts, \"售票员小兰\").start(); //注意，这里锁定的是对象ts} 线程的死锁多线程以及多进程改善了系统资源的利用率并提高了系统 的处理能力。然而，并发执行也带来了新的问题——死锁。所谓死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。 123456789101112131415161718192021222324252627282930public class TestDeadLock implements Runnable{ public int flag = 1; //定义两个静态变量，模拟作为两个锁对象 private static Object o1 = new Object(); private static Object o2 = new Object(); @Override public void run() { if (flag == 0) { synchronized (o1) { System.out.println(Thread.currentThread().getName() + \"：使用o1\"); synchronized (o2) { System.out.println(Thread.currentThread().getName() + \"：锁住o2\"); } } } if (flag == 1) { synchronized (o2) { System.out.println(Thread.currentThread().getName() + \"：使用o2\"); synchronized (o1) { System.out.println(Thread.currentThread().getName() + \"：锁住o1\"); } } } } } 123456789101112public static void main(String[] args) { TestDeadLock td1 = new TestDeadLock(); TestDeadLock td2 = new TestDeadLock(); td1.flag = 0; td2.flag = 1; //启动线程 new Thread(td1, \"小明\").start(); new Thread(td2, \"小红\").start();} 在多线程中，形成死锁的4个必要条件： 1.互斥使用 2.不可抢占 3.请求和等待 4.循环等待 Java中的死锁是应该尽量避免的，避免死锁，只需要避免4个条件中的任意一个即可；常用的方法：1.避免嵌套锁 2.设置锁定的顺序 3.设置锁定等待的时间 123456789/** * 模拟资源类 */public class ThreadResource { public static Object resource1 = new Object(); public static Object resource2 = new Object();} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 通过设置锁的顺序、设置锁定时间，来解决死锁问题 */public class MyThread implements Runnable{ @Override public void run() { try { System.out.println(Thread.currentThread().getName() +\"开始运行\"); //设置锁定的顺序 if (ThreadResource.resource1.hashCode() &gt; ThreadResource.resource2.hashCode() ) { //先锁定resource1 synchronized (ThreadResource.resource1) { System.out.println(Thread.currentThread().getName() + \"锁定资源1\"); Thread.sleep(2000); //设置锁定时间，避免无限锁定 synchronized (ThreadResource.resource2) { System.out.println(Thread.currentThread().getName() + \"锁定资源2\"); } System.out.println(Thread.currentThread().getName() + \"释放资源2\"); } System.out.println(Thread.currentThread().getName() + \"释放资源1\"); } else { //先锁定resource2 synchronized (ThreadResource.resource2) { System.out.println(Thread.currentThread().getName() + \"锁定资源2\"); Thread.sleep(2000); //设置锁定时间，避免无限锁定 synchronized (ThreadResource.resource1) { System.out.println(Thread.currentThread().getName() + \"锁定资源1\"); } System.out.println(Thread.currentThread().getName() + \"释放资源1\"); } System.out.println(Thread.currentThread().getName() + \"释放资源2\"); } } catch (Exception e) { System.out.println(e.getMessage()); } System.out.println(Thread.currentThread().getName() +\"线程结束\"); }} 1234public static void main(String[] args) { new Thread(new MyThread(),\"线程1 ： \").start(); new Thread(new MyThread(),\"线程2 ： \").start();}","link":"/2020/07/13/java/Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"title":"Java中的JDBC基础知识","text":"Java高级系列课程-Java中的JDBC基础知识 @程序猿付显 JDBC概述JDBC APIJDBC API 是一系列的接口，它使得应用程序能够进行数据库连接，执行SQL语句，并且得到返回结果。 Driver接口 Java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现 在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现 加载与注册JDBC驱动 加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名 DriverManager 类是驱动程序管理器类，负责管理驱动程序 通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例 常用的几种JDBC驱动类名 RDBMS JDBC驱动程序名称 MySQL com.mysql.jdbc.Driver SQLServer com.microsoft.sqlserver.jdbc.SQLServerDriver ORACLE oracle.jdbc.driver.OracleDriver DB2 com.ibm.db2.jdbc.net.DB2Driver 1Class.forName(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\"); 建立连接 可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接对象 Connection1Connection conn = DriverManager.getConnection(url, user, password); user password url 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。 JDBC URL的标准由三部分组成，各部分间用冒号分隔。 jdbc:&lt;子协议&gt;:&lt;子名称&gt; 协议：JDBC URL中的协议总是jdbc 子协议：子协议用于标识一个数据库驱动程序 子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息 RDBMS URL格式 MySQL jdbc:mysql://[hostName]:[portNumber]/[databaseName] SQLServer jdbc:sqlserver://[hostName]:[portNumber];databaseName=[databaseName] ORACLE jdbc:oracle:thin:@hostName:[portNumber]:[databaseName] DB2 jdbc:db2:[hostName]:[portNumber]/[databaseName] 注意: [hostName] :ip地址,一般本机为127.0.0.1 [portNumber]:数据库服务的端口,一般情况下:mysql为3306;SqlServer为1433 [databaseName]:我们所建立的数据库的名称 访问数据库 数据库连接被用于向数据库服务器发送命令和 SQL 语句，在连接建立后，需要对数据库进行访问，执行 sql 语句 在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式： Statement PrepatedStatement CallableStatement Statement 通过调用 Connection 对象的 createStatement() 方法创建该对象 该对象用于执行静态的 SQL 语句，并且返回执行结果 Statement 接口中定义了下列方法用于执行 SQL 语句： ResultSet excuteQuery(String sql) int excuteUpdate(String sql) PrepatedStatement 可以通过调用 Connection 对象的 preparedStatement() 方法获取 PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句 PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示调用 PreparedStatement 对象的 setXXX() 方法来设置这些参数. setXXX() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值 PrepatedStatement VS Statement 代码的可读性和可维护性 PreparedStatement 能最大可能提高性能： DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存.这样每执行一次都要对传入的语句编译一次. (语法检查，语义检查，翻译成二进制命令，缓存) PreparedStatement 可以防止 SQL 注入 ResultSet 通过调用 Statement 对象的 excuteQuery() 方法创建该对象 ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商实现 ResultSet 对象维护了一个指向当前数据行的游标，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行 ResultSet 接口的常用方法： boolean next() String getString() int getInt() … 释放关闭资源Connection PreparedStatement Statement ResultSet 等资源使用完毕之后必须进行关闭,类似我们之前讲过的IO流关闭是一样的道理.常使用 close()方法进行关闭 使用直连操作数据库操作数据库步骤: 1:加载jdbc驱动程序(项目中添加驱动包) 2:使用DriverManager建立到数据库的连接 3:准备sql语句 4:使用Statement访问数据库 5:使用ResultSet 或者 int 接收访问数据库的反馈结果 6:对结果进行输出或展示 7:关闭资源 123456789101112131415161718192021222324252627public static void main(String[] args) throws SQLException { // 1:加载jdbc驱动程序(项目中添加驱动包) try { Class.forName(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\"); } catch (ClassNotFoundException e) { e.printStackTrace(); } // 2:使用DriverManager建立到数据库的连接 Connection conn = DriverManager.getConnection(\"jdbc:sqlserver://127.0.0.1:1433;databaseName=school\", \"sa\", \"123\"); // 3:准备sql语句 String sql = \"select * from student\"; // 4:使用Statement访问数据库 Statement st = conn.createStatement(); // 5:使用ResultSet 或者 int 接收访问数据库的反馈结果 ResultSet rs = st.executeQuery(sql); // 6:对结果进行输出或展示 while (rs.next()) { System.out.println(rs.getString(\"name\")); } // 7:关闭资源 rs.close();} SQL攻击什么是SQL注入攻击当应用程序使用输入内容来构造动态sql语句以访问数据库时，会发生sql注入攻击。所谓SQL注入，就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令. 1String sql = \"select id from users where username = '\"+username +\"' and password = '\" + password +\"'\"; 这里的username和password都是我们存取从web表单获得的数据。下面我们来看一下一种简单的注入，如果我们在表单中username的输入框中输入’ or 1=1– ，password的表单中随便输入一些东西，假如这里输入123.此时我们所要执行的sql语句就变成了 1select id from users where username = '' or 1=1-- and password = '123' 我们来看一下这个sql，因为1=1是true，后面 and password = ‘123’被注释掉了。所以这里完全跳过了sql验证。 防止SQL注入攻击sql注入攻击是指利用设计上的漏洞，在目标服务器上运行Sql语句以及进行其他方式的攻击，动态生成Sql语句时没有对用户输入的数据进行验证是Sql注入攻击得逞的主要原因。对于Java数据库连接JDBC而言，SQL注入攻击只对Statement有效，对PreparedStatement是无效的，这是因为PreparedStatement不允许在不同的插入时间改变查询的逻辑结构.PreparedStatement相对Statement有以下优点： 1.防注入攻击 2.多次运行速度快 3.防止数据库缓冲区溢出 4.代码的可读性可维护性好 这四点使得PreparedStatement成为访问数据库的语句对象的首选，缺点是灵活性不够好，有些场合还是必须使用Statement。结合以上情况解决此类SQL注入攻击可以使用两种方案: 对提交的动态sql语句检查是否含有’or 1=1’等类似情况,并做出相应禁止措施 使用PreparedStatement 替换 Statement 完成注册功能下边我们通过以上知识的讲解完成一个控制台版的注册功能,需要用到一个学生用户表 student 表 字段名 数据类型 约束等说明 备注 id int 主键,自增 学生编号 name varchar(64) 不为空 学生姓名 user_name varchar(128) 唯一约束 学生登录名 pwd varchar(128) 不为空 密码 12","link":"/2020/07/13/java/Java%E4%B8%AD%E7%9A%84JDBC%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"Java的反射机制","text":"Java高级系列课程-Java的反射机制 @程序猿付显 反射的概念反射概述什么是反射？反射就是Reflection，JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的以及动态调用对象的方法的功能称为Java的反射机制 反射的使用场景 逆向代码 ，例如反编译 与注解相结合的框架 单纯的反射机制应用框架 动态生成类框架 Java反射API首先要分清楚Class类和关键词class的不同，虽然Class类名称上和class很相似，但两者其实没有什么关联。Class类也是一个Java类，它也可以实例化得到对象，与普通类不一样的是Class类中存储的是其它类的类型信息。而这些类型信息正是Java反射机制所需要的，Java的反射机制是由Class类和java.lang.reflect包下的Method、Field、Constructor等类支持的。下面就来了解下这几个类。 反射核心类-Class类类是程序的一部分，每个类都有一个Class对象，换而言之每编写一个新类，就会产生一个Class对象(更准确的来说，是被保存在一个同名的.class文件中)。当程序中需要使用到这个类的时候(包括需要这个类的对象或引用这个类的静态变量)就通过类加载器将类加到内存中来。在进行类加载的时候，类加载器会先检查这个类的Class对象是否已经加载，如果还未加载，则默认的类加载器就会根据类名查找.class文件(这里不一定都是从文件系统中获取，可以从数据库读取字节码或者接受网络中传输过来的字节码)。这些字节码在被加载的时候，会检查验证保证它们没有被破坏。一旦某个类的Class对象被载入内存，它就会被用来创建这个类的所有对象。下面来看下Class类一些操作。 获取Class对象的三种方式: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package org.fuxian.model;/** * 学生类 * @author fuxian.org * */public class Student { private int id; private String name; private String sex; private int age; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Student() { System.out.println(\"默认的无参的构造方法\"); } public Student(int id, String name, String sex, int age) { super(); this.id = id; this.name = name; this.sex = sex; this.age = age; }} 123456789101112131415161718192021222324252627282930package org.fuxian.reflectTest;import org.fuxian.model.Student;public class Test01 { public static void main(String[] args) { // 创建Student对象 Student student = new Student(); // Java反射机制获取Class对象的三种方法 // 第一种 通过对象名.getClass()方法获取 Class stuClass1 = student.getClass(); System.out.println(\"stuClass1 is \"+stuClass1.getName()); // 第二种 通过类名.class方式获取 Class stuClass2 = Student.class; System.out.println(\"stuClass2 is \"+stuClass2.getName()); System.out.println(stuClass1 == stuClass2); // 第三种 通过Class.forName(\"xxx\")方法获取 Class stuClass3 = null; try { stuClass3 = Class.forName(\"org.fuxian.model.Student\"); } catch (ClassNotFoundException e) { System.out.println(\"找不到这个类\"); } System.out.println(\"stuClass3 is \"+stuClass3); System.out.println(stuClass2 == stuClass3); }} 12345678控制台输出结果:默认的无参的构造方法stuClass1 is org.fuxian.model.StudentstuClass2 is org.fuxian.model.Studenttrue找不到这个类stuClass3 is nullfalse 通过结果我们可以发现在运行期间，一个类，只有一个Class对象产生 三种方式常用第三种第一种对象都有了还要反射干什么第二种需要导入类的包，依赖太强，不导包就抛编译错误一般都选第三种，一个字符串可以传入也可写在配置文件中等多种方法 反射辅助类-Method类我们通过反射获取了运行时的Class对象,我们通过可以获取他的所有的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package org.fuxian.reflectTest;import java.lang.reflect.Method;public class Test02 { public static void main(String[] args) { // 第三种 通过Class.forName(\"xxx\")方法获取 Class stuClass = null; try { stuClass = Class.forName(\"org.fuxian.model.Student\"); System.out.println(\"----------1:获取全部的public的函数----------\"); // 1:获取全部的public的函数(包括从父类继承的、从接口实现的所有public函数) Method[] methods = stuClass.getMethods(); for (Method method : methods) { System.out.println(method); } System.out.println(\"----------2:获取全部的类自身声明的函数----------\"); // 2:获取全部的类自身声明的函数，包含public、protected和private方法 Method[] methods2 = stuClass.getDeclaredMethods(); for (Method method : methods2) { System.out.println(method); } System.out.println(\"----------3:获取\\\"名称是name，参数是parameterTypes\\\"的public的函数----------\"); // 3:获取\"名称是name，参数是parameterTypes\"的public的函数(包括从父类继承的、从接口实现的所有public函数) try { Method method3 = stuClass.getMethod(\"getName\"); System.out.println(method3); } catch (NoSuchMethodException | SecurityException e) { e.printStackTrace(); } System.out.println(\"----------4:获取\\\"名称是name，参数是parameterTypes\\\"，并且是类自身声明的函数----------\"); // 4:获取\"名称是name，参数是parameterTypes\"，并且是类自身声明的函数，包含public、protected和private方法 try { Method method4 = stuClass.getDeclaredMethod(\"setName\", String.class); System.out.println(method4); } catch (NoSuchMethodException | SecurityException e) { e.printStackTrace(); } } catch (ClassNotFoundException e) { System.out.println(\"找不到这个类\"); } }} 1234567891011121314151617181920212223242526272829303132控制台输出结果:----------1:获取全部的public的函数----------public java.lang.String org.fuxian.model.Student.getName()public int org.fuxian.model.Student.getId()public void org.fuxian.model.Student.setName(java.lang.String)public void org.fuxian.model.Student.setSex(java.lang.String)public java.lang.String org.fuxian.model.Student.getSex()public void org.fuxian.model.Student.setId(int)public void org.fuxian.model.Student.setAge(int)public int org.fuxian.model.Student.getAge()public final void java.lang.Object.wait() throws java.lang.InterruptedExceptionpublic final void java.lang.Object.wait(long,int) throws java.lang.InterruptedExceptionpublic final native void java.lang.Object.wait(long) throws java.lang.InterruptedExceptionpublic boolean java.lang.Object.equals(java.lang.Object)public java.lang.String java.lang.Object.toString()public native int java.lang.Object.hashCode()public final native java.lang.Class java.lang.Object.getClass()public final native void java.lang.Object.notify()public final native void java.lang.Object.notifyAll()----------2:获取全部的类自身声明的函数----------public java.lang.String org.fuxian.model.Student.getName()public int org.fuxian.model.Student.getId()public void org.fuxian.model.Student.setName(java.lang.String)public void org.fuxian.model.Student.setSex(java.lang.String)public java.lang.String org.fuxian.model.Student.getSex()public void org.fuxian.model.Student.setId(int)public void org.fuxian.model.Student.setAge(int)public int org.fuxian.model.Student.getAge()----------3:获取&quot;名称是name，参数是parameterTypes&quot;的public的函数----------public java.lang.String org.fuxian.model.Student.getName()----------4:获取&quot;名称是name，参数是parameterTypes&quot;，并且是类自身声明的函数----------public void org.fuxian.model.Student.setName(java.lang.String) 反射辅助类-Field类还可以通过反射获取类中所有的属性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package org.fuxian.reflectTest;import java.lang.reflect.Field;public class Test03 { public static void main(String[] args) { // 第三种 通过Class.forName(\"xxx\")方法获取 Class stuClass = null; try { stuClass = Class.forName(\"org.fuxian.model.Student\"); System.out.println(\"------------1:根据变量名获得对应的变量，访问权限不限---------------\"); // 1:根据变量名获得对应的变量，访问权限不限 try { Field field1 = stuClass.getDeclaredField(\"name\"); System.out.println(field1); } catch (NoSuchFieldException | SecurityException e) { e.printStackTrace(); } System.out.println(\"------------2:获得类中所有属性变量 ，访问权限不限---------------\"); // 2:获得类中所有属性变量 ，访问权限不限 Field[] fields1 = stuClass.getDeclaredFields(); for (Field field : fields1) { System.out.println(field); } System.out.println(\"------------3:根据变量名获取对应public类型的属性变量---------------\"); // 3:根据变量名获取对应public类型的属性变量 try { Field field2 = stuClass.getField(\"name\"); System.out.println(field2); } catch (NoSuchFieldException | SecurityException e) { e.printStackTrace(); } System.out.println(\"------------4:获取类中所有public类型的属性变量-------------------\"); // 4:获取类中所有public类型的属性变量 Field[] fields2 = stuClass.getFields(); for (Field field : fields2) { System.out.println(field); } } catch (ClassNotFoundException e) { System.out.println(\"找不到这个类\"); } }} 123456789101112------------1:根据变量名获得对应的变量，访问权限不限---------------private java.lang.String org.fuxian.model.Student.name------------2:获得类中所有属性变量 ，访问权限不限---------------private int org.fuxian.model.Student.idprivate java.lang.String org.fuxian.model.Student.nameprivate java.lang.String org.fuxian.model.Student.sexprivate int org.fuxian.model.Student.age------------3:根据变量名获取对应public类型的属性变量---------------java.lang.NoSuchFieldException: name at java.lang.Class.getField(Class.java:1703) at org.fuxian.reflectTest.Test03.main(Test03.java:32)------------4:获取类中所有public类型的属性变量------------------- 反射辅助类-Constructor类通过反射获取类中的构造方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package org.fuxian.reflectTest;import java.lang.reflect.Constructor;public class Test04 { public static void main(String[] args) { // 第三种 通过Class.forName(\"xxx\")方法获取 Class stuClass = null; try { stuClass = Class.forName(\"org.fuxian.model.Student\"); System.out.println(\"----------1:返回所有public构造方法----------\"); Constructor[] constructors1 = stuClass.getConstructors(); for (Constructor constructor : constructors1) { System.out.println(constructor); } System.out.println(\"----------2:所有的构造方法(包括：私有、受保护、默认、公有)----------\"); Constructor[] constructors2 = stuClass.getDeclaredConstructors(); for (Constructor constructor : constructors2) { System.out.println(constructor); } System.out.println(\"----------3:返回指定类型的 public构造器----------\"); try { Constructor constructor1 = stuClass.getConstructor(String.class, int.class); System.out.println(constructor1); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (SecurityException e) { e.printStackTrace(); } System.out.println(\"----------4:返回指定类型的构造器----------\"); try { Constructor constructor2 = stuClass.getDeclaredConstructor(int.class); System.out.println(constructor2); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (SecurityException e) { e.printStackTrace(); } } catch (ClassNotFoundException e) { System.out.println(\"找不到这个类\"); } }} 12345678910111213141516----------1:返回所有public构造方法----------public org.fuxian.model.Student(int,java.lang.String,java.lang.String,int)public org.fuxian.model.Student()----------2:所有的构造方法(包括：私有、受保护、默认、公有)----------public org.fuxian.model.Student(int,java.lang.String,java.lang.String,int)public org.fuxian.model.Student()----------3:返回指定类型的 public构造器----------java.lang.NoSuchMethodException: org.fuxian.model.Student.&lt;init&gt;(java.lang.String, int)----------4:返回指定类型的构造器---------- at java.lang.Class.getConstructor0(Class.java:3082) at java.lang.Class.getConstructor(Class.java:1825) at org.fuxian.reflectTest.Test04.main(Test04.java:28)java.lang.NoSuchMethodException: org.fuxian.model.Student.&lt;init&gt;(int) at java.lang.Class.getConstructor0(Class.java:3082) at java.lang.Class.getDeclaredConstructor(Class.java:2178) at org.fuxian.reflectTest.Test04.main(Test04.java:38) 反射的简单应用123456789package org.fuxian.inter;public interface Animal { void run(); String cry(); String eat(String food);} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package org.fuxian.model;import org.fuxian.inter.Animal;public class Dog implements Animal { private String name; private int age; private String color; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } @Override public void run() { System.out.println(\"dog run...\"); } @Override public String cry() { return \"汪 汪 汪...\"; } @Override public String eat(String food) { return \"喜欢吃:\"+food; }} 123456789101112131415161718192021222324252627282930313233343536373839404142package org.fuxian.reflectTest;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class Test05 { public static void main(String[] args) {// String className = \"org.fuxian.model.Dog\";// String methodName = \"eat\";// String parameter = \"骨头\"; String className = \"org.fuxian.model.Sheep\"; String methodName = \"eat\"; String parameter = \"草\"; try { Class c = Class.forName(className); Object obj = c.newInstance(); Method eat = c.getDeclaredMethod(methodName, String.class); Object returnValue = eat.invoke(obj, parameter); System.out.println(returnValue); } catch (ClassNotFoundException e) { System.out.println(\"找不到这个类\"); } catch (InstantiationException | IllegalAccessException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (NoSuchMethodException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (SecurityException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IllegalArgumentException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (InvocationTargetException e) { // TODO Auto-generated catch block e.printStackTrace(); } }}","link":"/2020/07/13/java/Java%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"title":"Java中的异常和错误调试","text":"Java高级系列课程-Java中的异常和错误调试 @程序猿付显 异常的概述Java 中的异常（Exception）又称为例外，是一个在程序执行期间发生的事件，它中断正在执行程序的正常指令流。 任何人都无法保证程序永远准确运行，程序一旦出现异常，那么就像现实中碰到异常问题一样，需要得到及时的处理。异常处理是程序设计中一个非常重要的方面，也是程序设计的一个难点。即使你感觉自己写的程序是相当的棒，但在运行时还是有可能会出现意外的情况。 异常的分类Throwable类是Java语言中所有错误或异常的超类，这意味着只要是错误或者异常，那么肯定是Throwable子类的实例，但是事实上，由于错误，异常内容过于庞大，所以设计人员将他们分开来，这就是Throwable的两个子类，Error和Exception Error类负责错误，它指程序运行的时候遇到硬件或操作系统的错误，如内存溢出，堆栈溢出，动态链接错误，虚拟机JVM错误等，这些错误都是严重并且致命的，是依靠程序自身无法解决的 Exception则是运行时的错误，它可以被捕获并处理 Exception又分为两大类： 运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般由程序逻辑错误引起，程序应该从逻辑角度尽可能避免这类异常的发生。 非运行时异常是指RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、ClassNotFoundException等以及用户自定义的Exception异常 常见的异常 异常 备注 RuntimeException Java.lang包中多数异类的基类 ArithmeticException 算数错误，除数为0 ArraylndexOutOfBoundException 数组大小小于或大于实际的数组大小 ClassNotFoundException 不能加载所需的类 NumberFormatException 从字符串到数据类型的非法转换 NullPointerException null指针异常 FileNotFoundException 文件没有找到 IOException IO异常 InterruptedException 线程中断 IllegalArgumentException 方法接收到非法参数 ClassCastException 类型转换异常 SQLException SQL数据库异常 异常的处理捕获异常Java异常处理通过5个关键字控制：try，catch，throw，throws和finally,捕获异常使用try…catch语句，把可能发生异常的代码放到try {…}中，然后使用catch捕获对应的Exception及其子类： 1try{ //要监控是否有异常的代码 //代码A //代码B }catch(ExceptionType et1){ //对异常1进行处理 }catch(ExceptionType et2){ //对异常2进行处理 }finally{ //try模块结束前必须执行的代码块 } try catch123456789101112Scanner input = new Scanner(System.in);try { System.out.println(\"请输入被除数：\"); int i1 = input.nextInt(); System.out.println(\"请输入除数：\"); int i2 = input.nextInt(); int result = i1 / i2; System.out.println(\"运行结果是：\" + result);} catch (InputMismatchException ie) { System.out.println(\"输入的必须为数字\"); System.out.println(ie.getMessage());} 多catch123456789101112131415Scanner input = new Scanner(System.in);try { System.out.println(\"请输入被除数：\"); int i1 = input.nextInt(); System.out.println(\"请输入除数：\"); int i2 = input.nextInt(); int result = i1 / i2; System.out.println(\"运行结果是：\" + result);} catch (ArithmeticException ae) { System.out.println(\"除数不能为0\"); System.out.println(ae.getMessage());} catch (InputMismatchException ie) { System.out.println(\"输入的必须为数字\"); System.out.println(ie.getMessage());} 嵌套try catch1234567891011121314151617Scanner input = new Scanner(System.in);try { try { System.out.println(\"请输入被除数：\"); int i1 = input.nextInt(); System.out.println(\"请输入除数：\"); int i2 = input.nextInt(); int result = i1 / i2; System.out.println(\"运行结果是：\" + result); } catch (ArithmeticException ae) { System.out.println(\"输入的必须为数字\"); System.out.println(ae.getMessage()); }} catch (InputMismatchException ie) { System.out.println(\"除数不能为0\"); System.out.println(ie.getMessage());} finally关键字有些时候，try块内引用了一些物理资源，例如数据库连接，网络连接或磁盘文件等。那么一旦try块内出现了异常，这些资源将无法保证可以释放。这时候我们是不是可以把资源释放的处理放在catch中执行呢？当然是不可以的，因为catch操作很可能不会被执行，如果没有发生异常，那么就不会有资源释放的操作了。所以必须有一种可以明确保证资源一定得到释放的操作，不管是否存在异常，这就是finally存在的原因。 1234567891011121314151617181920Scanner input = new Scanner(System.in);try { try { System.out.println(\"请输入被除数：\"); int i1 = input.nextInt(); System.out.println(\"请输入除数：\"); int i2 = input.nextInt(); int result = i1 / i2; System.out.println(\"运行结果是：\" + result); } catch (ArithmeticException ae) { System.out.println(\"输入的必须为数字\"); System.out.println(ae.getMessage()); }} catch (InputMismatchException ie) { System.out.println(\"除数不能为0\"); System.out.println(ie.getMessage());} finally { System.out.println(\"不管前边是否有异常,这个地方一定会被执行的,一般在这个地方处理跟资源相关的关闭操作\"); System.out.println(\"执行完成\");} 抛出异常在Java系统中，我们不仅可以使用try-catch来捕捉异常，还可以使用throw语句来显式的引发异常，执行的代码一旦遇到throw语句，就会立即停止，不会继续往后执行。其语法为： 1throw &lt;Throwable instance&gt; 实例: 1234567891011121314151617public static void main(String[] args) { try { method1(); } catch (IOException e) { System.out.println(\"这个地方进行异常的捕获\"); System.out.println(e.getMessage()); }}public static void method1() throws IOException { method2();}public static void method2() throws IOException { System.out.println(\"before\"); throw new IOException();} throwthrow是显示的抛出一个异常，一般是在代码块的内部，当程序出现某种逻辑错误时由程序员主动抛出特定类型的异常 throwsthrows是方法可能抛出异常的声明，用在声明方法时，表示该方法可能抛出异常，然后交给上层调用它的方法处理 区别 throw出现在方法体，throws出现在方法头 throw是抛出了异常，执行throw则一定是抛出了某种异常，throws是表示出现异常的一种可能性，并不一定会抛出这些异常 自定义异常当我们在代码中需要抛出异常时，尽量使用JDK已定义的异常类型,在一些大型项目中，可能需要自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。 一个常见的做法是自定义一个BaseException作为“根异常”，然后，派生出各种业务类型的异常。 BaseException需要从一个适合的Exception派生，通常建议从RuntimeException派生： 123public class BaseException extends RuntimeException {} 其他业务类型的异常就可以从BaseException派生： 12345public class UserNotFoundException extends BaseException {}public class LoginFailedException extends BaseException {} 自定义的BaseException应该提供多个构造方法： 1234567891011121314151617public class BaseException extends RuntimeException { public BaseException() { super(); } public BaseException(String message, Throwable cause) { super(message, cause); } public BaseException(String message) { super(message); } public BaseException(Throwable cause) { super(cause); }} Tips求生技能提问时最好贴出异常,否则… 最常见的异常出现的位置:","link":"/2020/07/13/java/Java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%92%8C%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/"},{"title":"Java中的IO","text":"Java高级系列课程-Java中的IO @程序猿付显 流的概述流 IO在 Java 中所有数据都是使用流读写的。那么什么是流呢？流是一组有序的数据序列，将数据从一个地方带到另一个地方。其实Java IO流和水流是类似的，他们具有最基本的特点，即流是一维的，流是单向的，对应的操作就是单向读取和单向写入的。根据数据流向的不同，可以分为输入（Input）流和输出（Output）流两种。 IOIO: Java中的输入和输出操作Java 中的IO主要包含3个部分： 1.流式部分—IO的主体部分 2.非流式部分—辅助流式部分,如File类 3.文件读取部分和安全相关的类 我们在这里主要讲解File类与如何操作IO流Java IO流可以概括为“两个对应，一个桥梁”： 两个对应指字节流和字符流的对应，输入流和输出流的对应； 一个桥梁指字节流到字符流的桥梁。 分别由以下4个抽象类来表示流：InputStream、OutputStream、Reader、Writer File类File 类是文件和目录路径名的抽象形式,它提供了与平台无关的方法来对磁盘上的文件或目录进行操作使用 File 类可以获取文件本身的一些信息，例如文件所在的目录、文件长度、文件读写权限等Java中，File类是java.io包中唯一代表磁盘文件本身的对象。File 类表示处理文件和文件系统的相关信息。也就是说，File 类不具有从文件读取信息和向文件写入信息的功能，它仅描述文件本身的属性。File构造方法: 方法名称 方法说明 File(File parent,String child) 根据 parent 抽象路径名和child路径名字符串创建一个新 File 实例 File(String pathname) 通过将给定路径名字符串转换成抽象路径名来创建一个File实例 File(String parent,String child) 根据 parent 路径名字符串和child路径名字符串创建一个新File实例 File(URI uri) 通过将给定的File:URI转换成一个抽象路径名来创建一个新的File实例 File类常用方法: 方法名称 方法说明 String getPath() 获取此File类构造方法中的路径 String getAbsolutePath() 获取文件或文件夹绝对路径 String getName() 获取文件或文件夹名字 boolean isFile() 是否是文件 boolean exists() 是否存在此文件或目录 boolean isDirectory() 是否是目录 boolean canRead() 是否可读 boolean canWrite() 是否可写 boolean canExecute() 是否可执行 long length() 文件字节大小 boolean createNewFile() 创建文件 boolean delete() 删除文件或文件夹,如果删除当前File对象表示的目录，当前目录必须为空才能删除成功 boolean mkdir() 创建当前File对象表示的目录 boolean mkdirs() 创建当前File对象表示的目录,并在必要时将不存在的父目录也创建出来 String[] list() 返回此文件夹下所有的文件及文件夹名称 File[] listFiles() 返回此文件夹下所有的文件及文件夹File对象 字节流Java中的字节流根据流向的不同，可以分为输入流和输出流；字节输入流类的父类是 InputStream，它是一个抽象类；字节输出流类的父类是 OutputStream，它也是一个抽象类 FileInputStream该流用于从文件读取数据，它的对象可以用关键字 new 来创建。有多种构造方法可用来创建对象可以使用字符串类型的文件名来创建一个输入流对象来读取文件： 1FileInputStream fileInputStream = new FileInputStream(\"D:/test/1.txt\"); 也可以使用一个文件对象来创建一个输入流对象来读取文件: 12File file = new File(\"D:/test/1.txt\");FileInputStream fileInputStream = new FileInputStream(file); FileInputStream字节输入流常用的方法: 使用FileInputStream读取普通文本文件 123456789101112131415161718192021public static void main(String[] args) { FileInputStream f = null; try { f = new FileInputStream(\"D:/test/1.txt\"); byte[] b = new byte[1024]; int n = f.read(b); System.out.println(n); String str = new String(b, 0, n); System.out.println(str); } catch (FileNotFoundException e) { System.err.println(\"找不到这个文件!\"); } catch (IOException e) { System.err.println(\"读取文件出现问题!\"); } finally { try { f.close(); } catch (IOException e) { System.err.println(\"输入流关闭出现问题!\"); } }} FileOutputStream该类用来创建一个文件并向文件中写数据。如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件.有两个构造方法可以用来创建 FileOutputStream 对象。使用字符串类型的文件名来创建一个输出流对象： 1FileOutputStream fileOutputStream = new FileOutputStream(\"D:/test/2.txt\"); 也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象： 12File file = new File(\"D:/test/2.txt\");FileOutputStream fileOutputStream = new FileOutputStream(file); FileOutputStream字节输出流常用的方法: 使用FileOutputStream将字符串写入普通文本文件中 12345678910111213141516public static void main(String[] args) { FileOutputStream fileOutputStream = null; try { fileOutputStream = new FileOutputStream(\"D:/test/2.txt\"); String str = \"sdsfsfsf\"; fileOutputStream.write(str.getBytes()); } catch (Exception e) { System.err.println(\"写入流出错了!\"); } finally { try { fileOutputStream.close(); } catch (IOException e) { System.err.println(\"字节输出流关闭失败!\"); } }} 字符流 Reader是一个字符输入流，以char为单位读取Writer是一个字符输出流，以char为单位读取 为了提高字符流读写的效率，引入了缓冲机制，进行字符批量的读写，提高了单个字符读写的效率。BufferedReader用于加快读取字符的速度，BufferedWriter用于加快写入的速度 BufferedReader和BufferedWriter类各拥有8192个字符的缓冲区。当BufferedReader在读取文本文件时，会先尽量从文件中读入字符数据并放满缓冲区，而之后若使用read()方法，会先从缓冲区中进行读取。如果缓冲区数据不足，才会再从文件中读取，使用BufferedWriter时，写入的数据并不会先输出到目的地，而是先存储至缓冲区中。如果缓冲区中的数据满了，才会一次对目的地进行写出。 BufferedReaderBufferedReader是为了提供读的效率而设计的一个包装类，它可以包装字符流。可以从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。 构造方法: BufferedReader字符输入流常用的方法: 使用BufferedReader字符输出流读取文本内容 123456789101112131415161718192021public static void main(String[] args) { BufferedReader br = null; try { br = new BufferedReader(new FileReader(\"d:/test/1.txt\")); String line = \"\"; while ((line = br.readLine()) != null) { System.out.println(line); } } catch (FileNotFoundException e) { System.err.println(\"找不到文件!\"); } catch (IOException e) { System.err.println(\"字符流读取出错!\"); } finally { try { if (br != null) br.close(); } catch (IOException e) { System.err.println(\"输入流关闭出错!\"); } }} BufferedWriterBufferedWriter构造方法: BufferedWriter字符输出流常用的方法: 使用BufferedWriter字符输出流写入文本文件 123456789101112131415161718192021public static void main(String[] args) { BufferedWriter writer = null; try { writer = new BufferedWriter(new FileWriter(\"d:/test/2.txt\")); String nextLine = \"明天交准时大作业!\"; // 写入一个字符串。 writer.write(nextLine); writer.newLine();// 写入换行符 } catch (FileNotFoundException e) { System.err.println(\"文件找不到!\"); } catch (IOException e) { System.err.println(\"写入文件失败!\"); } finally { try { if (writer != null) writer.close(); } catch (IOException e) { System.err.println(\"字符输出流关闭失败!\"); } }} Java虚拟机的功能类似一个翻译，将机器不能识别的字节码文件解释成机器代码","link":"/2020/07/13/java/Java%E4%B8%AD%E7%9A%84IO/"},{"title":"SqlServer中查询分析器的使用","text":"SQL基础系列课程-SqlServer中查询分析器的使用 @程序猿付显 使用查询分析器管理数据库SQL结构化查询语言(Structured Query Language) 简称SQL,是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统；同时也是数据库脚本文件的扩展名T-SQLT-SQL 即 Transact-SQL，是 SQL 在 Microsoft SQL Server 上的增强版，它是用来让应用程序与 SQL Server 沟通的主要语言。T-SQL 提供标准 SQL 的 DDL 和 DML 功能，加上延伸的函数、系统预存程序以及程序设计结构(例如 if 和 while)让程序设计更有弹性 创建数据库创建数据库语法: 1CREATE DATABASE 数据库名 ON [PRIMARY] ( &lt;数据文件参数&gt; [, …n] [&lt;文件组参数&gt;] ) [LOG ON] ( {&lt;日志文件参数&gt; [, …n ]} ) 实例: 1CREATE DATABASE school ON PRIMARY -- 默认就属于PRIMARY 主文件组，可省略 ( -- 数据文件的具体描述 NAME='school_data', --主数据文件的逻辑名 FILENAME='D:\\DATA\\school_data.mdf', --主数据文件的物理名 SIZE=5MB, --主数据文件的初始大小 MAXSIZE=50MB, --主数据文件增长的最大值 FILEGROWTH = 10% --主数据文件的增长率 ) LOG ON ( --日志文件的具体描述，各参数含义同上 NAME='school_log', FILENAME='D:\\DATA\\school_log.ldf', SIZE=5MB, FILEGROWTH=1MB ) 删除数据库删除数据库语法: 1DROP DATABASE 数据库名 实例: 1--删除school数据库 DROP DATABASE school 使用查询分析器管理表创建表创建表语法: 1CREATE TABLE 表名 ( 字段1 数据类型 属性 [约束], 字段2 数据类型 属性 [约束], ... ) 实例: 1234--创建学生信息表(student) CREATE TABLE student --创建学生信息表 ( id int NOT NULL , --学生序号，非空 name varchar(64) NOT NULL, --学生姓名，非空 sex varchar(4) NOT NULL, --学生性别，非空 age int NOT NULL, --学生年龄 , 非空 clazz_id int NOT NULL, --学生班级编号,非空 stu_num varchar(64) NOT NULL --学号,非空 )--创建班级表CREATE TABLE clazz --创建班级信息表 ( id int NOT NULL , --班级序号，非空 name varchar(64) NOT NULL, --学生姓名，非空 teacher_name varchar(4) NOT NULL, --学生性别，非空 ) 删除表删除表语法: 1DROP TABLE 表名 实例: 1--删除学生信息表 DROP TABLE student 使用查询分析器创建和删除约束常见的约束 主键约束（primary key constraint） 唯一约束（unique constraint） 检查约束（check constraint） 默认约束（default constraint） 外键约束（foreign key constraint 添加约束添加约束的语法: 1ALTER TABLE 表名 ADD CONSTRAINT 约束名 约束类型 具体的约束说明 实例: 1234--为学生信息表添加主键 ALTER TABLE student ADD CONSTRAINT PK_id PRIMARY KEY (id) --为学生信息表添加默认约束 ALTER TABLE student ADD CONSTRAINT DF_sex DEFAULT ('男') FOR sex --为学生信息表添加检查约束 ALTER TABLE student ADD CONSTRAINT CK_age CHECK(age &gt; 1) --为学生信息表添加外键约束 ALTER TABLE student ADD CONSTRAINT FK_clazz_id FOREIGN KEY(clazz_id) REFERENCES clazz(id) --为学生信息表添加唯一键 ALTER TABLE student ADD CONSTRAINT UQ_stu_num UNIQUE (stu_num) --为班级信息表添加主键 ALTER TABLE clazz ADD CONSTRAINT PK_id PRIMARY KEY (id) 更简洁的添加约束方法其实在创建表结构时可以直接将所要添加的约束写在建表语句中,这样可以省掉很多代码 1234--创建班级信息表 CREATE TABLE clazz ( id int NOT NULL PRIMARY KEY IDENTITY(1,1), --主键自增 name varchar(64) NOT NULL, --学生姓名，非空 teacher_name varchar(4) NOT NULL, --学生性别，非空 )--创建学生信息表 CREATE TABLE student ( id int NOT NULL PRIMARY KEY IDENTITY(1,1) , --主键自增 name varchar(64) NOT NULL, --学生姓名，非空 sex varchar(4) NOT NULL DEFAULT ('男'), --默认约束 age int NOT NULL CHECK(age &gt; 1), --检查约束 clazz_id int NOT NULL REFERENCES clazz(id),--外键约束 stu_num varchar(64) NOT NULL UNIQUE --唯一约束 ) 删除约束语法: 1ALTER TABLE 表名 DROP CONSTRAINT 约束名 实例: 1--删除学生信息表中的默认约束 ALTER TABLE student DROP CONSTRAINT DF_sex 本章给大家讲解了查询分析器的使用 下一章我们将利用查询分析器及所学的建库建表约束语句结合select语句完成简单查询","link":"/2020/07/13/SqlServer/SqlServer%E4%B8%AD%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"Java网络编程","text":"Java高级系列课程-Java网络编程 @程序猿付显 网络概述计算机网络基础在学习Java网络编程之前，我们先来了解什么是计算机网络。计算机网络是指两台或更多的计算机组成的网络，在同一个网络中，任意两台计算机都可以直接通信，因为所有计算机都需要遵循同一种网络协议。那什么是互联网呢？互联网是网络的网络（internet），即把很多计算机网络连接起来，形成一个全球统一的互联网。 网络通信协议对某个特定的计算机网络来说，它可能使用网络协议ABC，而另一个计算机网络可能使用网络协议XYZ。如果计算机网络各自的通讯协议不统一，就没法把不同的网络连接起来形成互联网。因此，为了把计算机网络接入互联网，就必须使用TCP/IP协议。TCP/IP协议泛指互联网协议，其中最重要的两个协议是TCP协议和IP协议。只有使用TCP/IP协议的计算机才能够联入互联网，使用其他网络协议（例如NetBIOS、AppleTalk协议等）是无法联入互联网的。 IP地址和端口IP地址在互联网中，一个IP地址用于唯一标识一个网络接口（Network Interface）。一台联入互联网的计算机肯定有一个IP地址，但也可能有多个IP地址 在网络编程中，可以使用IP或域名来标识网络上的一台设备。IP地址分为IPv4和IPv6两种。IPv4采用32位地址，类似101.202.99.12，而IPv6采用128位地址，类似2001:0DA8:100A:0000:0000:1020:F2F3:1428。IPv4地址总共有232个（大约42亿），而IPv6地址则总共有2128个（大约340万亿亿亿亿），IPv4的地址目前已耗尽，而IPv6的地址是根本用不完的。IP地址又分为公网IP地址和内网IP地址。公网IP地址可以直接被访问，内网IP地址只能在内网访问。内网IP地址: 192.168.1.1 127.0.0.1 外网IP地址: 220.181.38.150 185.199.108.153 端口为了在一台设备上可以运行多个程序，人为的设计了端口(Port)的概念，类似的例子是公司内部的分机号码。规定一个设备有216个，也就是65536个端口，每个端口对应一个唯一的程序。每个网络程序，无论是客户端还是服务器端，都对应一个或多个特定的端口号。由于0-1024之间多被操作系统占用，所以实际编程时一般采用1024以后的端口号。下面是一些常见的服务对应的端口： ftp:23 http:80 https:443 sqlserver:1433 mysql:3306 tomcat:8080 URL及其应用URL（Uniform Resource Locator）中文名为统一资源定位符，有时也被俗称为网页地址。表示为互联网上的资源，如网页或者FTP地址 1protocol://host:port/path?query#fragment URL 解析： 协议为(protocol)：http 主机为(host:port)：www.runoob.com 端口号为(port): 80 ，以上URL实例并未指定端口，因为 HTTP 协议默认的端口号为 80。 文件路径为(path)：/index.html 请求参数(query)：language=cn 定位位置(fragment)：j2se，定位到网页中 id 属性为 j2se 的 HTML 元素位置 。 构造方法: 常用方法: 例子: 12345678910111213141516171819202122import java.net.*;import java.io.*; public class URLDemo{ public static void main(String [] args){ try{ URL url = new URL(\"http://www.fuxian.org/2020/03/10/java/Java%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%8E%E6%B3%9B%E5%9E%8B/#more\"); System.out.println(\"URL 为：\" + url.toString()); System.out.println(\"协议为：\" + url.getProtocol()); System.out.println(\"验证信息：\" + url.getAuthority()); System.out.println(\"文件名及请求参数：\" + url.getFile()); System.out.println(\"主机名：\" + url.getHost()); System.out.println(\"路径：\" + url.getPath()); System.out.println(\"端口：\" + url.getPort()); System.out.println(\"默认端口：\" + url.getDefaultPort()); System.out.println(\"请求参数：\" + url.getQuery()); System.out.println(\"定位位置：\" + url.getRef()); }catch(IOException e){ e.printStackTrace(); } }} InetAddress及其应用InetAddress在java.net包下,主要用于IP地址和域名常用方法: 方法名 说明 InetAddress getByName(String s) 获得一个InetAddress 类的对象，该对象中含有主机的IP地址和域名 String getHostName() 获取InetAddress对象的域名 String getHostAddress() 获取InetAddress对象的IP地址 InetAddress getLocalHost() 获得一个InetAddress对象，该对象含有本地机的域名和IP地址 123456789101112131415161718192021import java.io.IOException;import java.net.InetAddress;import java.net.UnknownHostException;public class Test { public static void main(String[] args) { try { InetAddress locAdd = InetAddress.getLocalHost(); // 得到本地InetAddress对象 InetAddress remAdd = InetAddress.getByName(\"www.fuxian.org\"); // 取得远程InetAddress对象 System.out.println(\"本机IP地址：\" + locAdd.getHostAddress()); // 得到本地IP地址 System.out.println(\"博客IP地址：\" + remAdd.getHostAddress()); // 得到博客IP地址 System.out.println(\"博客域名：\" + remAdd.getHostName()); // 得到博客域名 System.out.println(\"本机是否可达：\" + locAdd.isReachable(10000)); // 10000是超时时间，10s } catch (UnknownHostException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } }} 使用TCP协议的SocketTCP 是传输控制协议的缩写，它保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP/IPSocket套接字使用TCP提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。当连接建立时，服务器会创建一个 Socket 对象。客户端和服务器现在可以通过对 Socket 对象的写入和读取来进行通信java.net.Socket 类代表一个套接字，并且 java.net.ServerSocket 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。 单向通信首先建立服务器端Socket步骤如下: 11:建立服务器端套接字,指定监听端口 2:监听,等待客户端请求,并愿意接受连接 3:获取Socket的输出流,并使用缓冲流进行包装 4:向客户端发送反馈信息 5:关闭流及Socket连接 实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package Socket;import java.io.BufferedWriter;import java.io.IOException;import java.io.OutputStreamWriter;import java.net.ServerSocket;import java.net.Socket;public class Server { public static void main(String[] args) { Socket socket = null; BufferedWriter writer = null; try { // 1:建立服务器端套接字,指定监听端口 ServerSocket ss = new ServerSocket(8888); System.out.println(\"服务器建立监听中...\"); // 2:监听,等待客户端请求,并愿意接受连接 socket = ss.accept(); // 3:获取Socket的输出流,并使用缓冲流进行包装 writer = new BufferedWriter(new OutputStreamWriter( socket.getOutputStream())); // 4:向客户端发送反馈信息 writer.write(socket.getInetAddress().getHostAddress() + \"客户端,你好!\"); } catch (Exception e) { e.printStackTrace(); } finally { // 5:关闭流 if (writer != null) { try { writer.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } if (socket != null) { try { socket.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } }} 再创建客户端Socket创建步骤: 11:创建一个Socket对象 2:获取Socket的输入流,并使用缓冲流进行包装 3接收服务器端发送的信息 4:关闭流及Socket连接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package Socket;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.Socket;public class Client { public static void main(String[] args) { Socket socket = null; BufferedReader read = null; try { // 1:创建一个Socket对象 socket = new Socket(\"127.0.0.1\", 8888); // 2:获取Socket的输入流,并使用缓冲流进行包装 read = new BufferedReader(new InputStreamReader( socket.getInputStream())); // 3:接收服务器端发送的信息 String line = read.readLine(); System.out.println(\"服务器:\" + line); } catch (Exception ex) { ex.printStackTrace(); } finally { // 4:关闭流及Socket连接 if (read != null) { try { read.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } if (socket != null) { try { socket.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } }} 双向通信双向通信就是服务器发送给客户端,客户端收到消息后也可以给服务器发送消息,服务器也能够收到消息 双向通信服务器端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package Socket;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.ServerSocket;import java.net.Socket;public class DoubleServer { public static void main(String[] args) { Socket socket = null; BufferedWriter writer = null; BufferedReader reader = null; BufferedReader consoleIn = null; try { // 1:建立服务器端套接字,指定监听端口 ServerSocket ss = new ServerSocket(8888); System.out.println(\"服务器建立监听中...\"); // 2:监听,等待客户端请求,并愿意接受连接 socket = ss.accept(); // 3:获取Socket的输出流,并使用缓冲流进行包装 // 输出流--&gt;我想客户端发送的内容 writer = new BufferedWriter(new OutputStreamWriter( socket.getOutputStream())); // 输入流 --&gt;客户端向我发送的内容 reader = new BufferedReader(new InputStreamReader( socket.getInputStream())); // 控制台输入流--&gt;控制台向我发送的内容/控制台输入的内容 consoleIn = new BufferedReader(new InputStreamReader(System.in)); while (true) { String fromClient = reader.readLine();// 读取输入流的内容(读取客户端向我发送的内容) System.out.println(\"客户端说了:\" + fromClient); // 4:向客户端发送反馈信息 String toClient = consoleIn.readLine();// 读取控制台输入的内容 if (toClient.contains(\"end\") || fromClient.contains(\"end\")) break; writer.write(toClient + \"\\n\");// 写入到输出流--&gt;发送到客户端 writer.flush();// 刷新--&gt;传输到客户端 } } catch (Exception e) { e.printStackTrace(); } finally { // 5:关闭流 if (writer != null) { try { writer.close(); } catch (IOException e) { e.printStackTrace(); } } if (reader != null) { try { reader.close(); } catch (IOException e) { e.printStackTrace(); } } if (consoleIn != null) { try { consoleIn.close(); } catch (IOException e) { e.printStackTrace(); } } if (socket != null) { try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } }} 双向通信客户端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package Socket;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.Socket;public class DoubleClient { public static void main(String[] args) { Socket socket = null; BufferedWriter writer = null; BufferedReader reader = null; BufferedReader consoleIn = null; try { // 1:创建一个Socket对象 socket = new Socket(\"127.0.0.1\", 8888); // 2:获取Socket的输入流,并使用缓冲流进行包装 // 输出流 --&gt;我向服务器端发送的内容 writer = new BufferedWriter(new OutputStreamWriter( socket.getOutputStream())); // 输入流 --&gt;服务器端向我发送的内容 reader = new BufferedReader(new InputStreamReader( socket.getInputStream())); // 控制台输入流 --&gt;控制台输入的内容 consoleIn = new BufferedReader(new InputStreamReader(System.in)); while (true) { // 3:向服务器端发送反馈信息 String toServer = consoleIn.readLine();// 获取控制台输入流--&gt;获取控制台输入的内容 if (toServer.contains(\"end\")) { break; } writer.write(toServer + \"\\n\");// 写入输出流--&gt;发送给服务器端的内容 writer.flush();// 刷新--&gt;发送到服务器端 String fromServer = reader.readLine();// 获取输入流的内容--&gt;获取服务器端发送给我的数据 System.out.println(\"服务器端说了:\" + fromServer);// 显示数据 } } catch (Exception ex) { ex.printStackTrace(); } finally { // 4:关闭流及Socket连接 // 5:关闭流 if (writer != null) { try { writer.close(); } catch (IOException e) { e.printStackTrace(); } } if (reader != null) { try { reader.close(); } catch (IOException e) { e.printStackTrace(); } } if (consoleIn != null) { try { consoleIn.close(); } catch (IOException e) { e.printStackTrace(); } } if (socket != null) { try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } }} 使用多线程实现多客户端通信数据报通信(UDP)UDP网络通信UDP数据广播","link":"/2020/07/13/java/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[],"categories":[{"name":"开篇","slug":"开篇","link":"/categories/%E5%BC%80%E7%AF%87/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"SqlServer","slug":"SqlServer","link":"/categories/SqlServer/"},{"name":"前人经验","slug":"前人经验","link":"/categories/%E5%89%8D%E4%BA%BA%E7%BB%8F%E9%AA%8C/"},{"name":"Java 高级","slug":"Java-高级","link":"/categories/Java-%E9%AB%98%E7%BA%A7/"},{"name":"2020暑期项目-在线考试系统","slug":"2020暑期项目-在线考试系统","link":"/categories/2020%E6%9A%91%E6%9C%9F%E9%A1%B9%E7%9B%AE-%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95%E7%B3%BB%E7%BB%9F/"}]}